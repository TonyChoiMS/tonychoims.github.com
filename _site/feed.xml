<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Type on Strap</title>
    <description>A website with blog posts and pages</description>
    <link>http://localhost:4000/Type-on-Strap/</link>
    <atom:link href="http://localhost:4000/Type-on-Strap/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Aug 2018 23:56:46 +0900</pubDate>
    <lastBuildDate>Thu, 09 Aug 2018 23:56:46 +0900</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Unreal Engine Socket과 Weapon에 대해서..</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최종 업데이트 : 2018-04-10&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소켓과-총-붙이기&quot;&gt;소켓과 총 붙이기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;본에는 등이나 팔과 같이 특정 부위에 소켓을 붙일 수 있는데, 이 소켓에 총을 붙일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;작업-프로세스&quot;&gt;작업 프로세스&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐릭터 skeleton 클래스로 들어가서 원하는 부위의 스켈레톤에 소켓을 추가한다.&lt;/li&gt;
  &lt;li&gt;소켓에 프리뷰를 통해 총 에셋을 미리 구현시킨다.&lt;/li&gt;
  &lt;li&gt;몸과 총이 어색하지 않도록 각도를 조정한다.&lt;/li&gt;
  &lt;li&gt;캐릭터 블루프린트 클래스로 들어가서 Mesh가 Root가 되도록 static mesh를 새로 생성한다.&lt;/li&gt;
  &lt;li&gt;생성된 static mesh에 이름을 부여한 후, 소켓-&amp;gt;부모 소켓에 skeleton 클래스에서 선언했던 소켓을 추가한다.&lt;/li&gt;
  &lt;li&gt;static mesh에 원하는 총의 이미지를 집어넣는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;총-장착-및-조준-애니메이션&quot;&gt;총 장착 및 조준 애니메이션&lt;/h1&gt;

&lt;h2 id=&quot;작업-프로세스-1&quot;&gt;작업 프로세스&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 세팅 -&amp;gt; 입력 칸으로 가서 Action Mapping을 통해 입력받을 키와 행동 이름을 추가한다.&lt;/li&gt;
  &lt;li&gt;캐릭터 블루프린트로 들어가서 추가한 행동 이름에 대한 함수를 호출한다.&lt;/li&gt;
  &lt;li&gt;equip rifle -&amp;gt; 토글키&lt;/li&gt;
  &lt;li&gt;aiming -&amp;gt; 누르고 있을 때만 true, 떼면 false&lt;/li&gt;
  &lt;li&gt;언리얼 엔진 블루프린트에서 bool 값의 네모칸이 빈칸이면 false, 체크되있으면 true&lt;/li&gt;
  &lt;li&gt;bool형 변수를 선언하여 포즈를 블렌딩합니다.
    &lt;h2 id=&quot;set-static-mesh-함수---컴포넌트의-static-mesh를-노드의-공간에서-추가할-수-있는-함수&quot;&gt;Set static mesh 함수 -&amp;gt; 컴포넌트의 static mesh를 노드의 공간에서 추가할 수 있는 함수.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;위젯-블루프린트-&quot;&gt;위젯 블루프린트 &lt;CrossHair 추가=&quot;&quot;&gt;&lt;/CrossHair&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;size to content : 원본 사이즈에 맞춰서 위젯의 크기를 조정해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;앵커 : 위젯의 위치를 잡아주는 툴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Alignment(정렬)&lt;/li&gt;
  &lt;li&gt;위젯의 피봇 위치.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽 위가 (0,0)이며, 오른쪽 아래가 (1,1)이다. 정렬 위치 조절을 통해 위젯 원점의 위치를 조절할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create Widget : 위젯을 생성하는 함수.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;get player controller : 0번째 인덱스는 무조건 내꺼(사용자).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Widget-&amp;gt;Add to Viewport : 뷰포트에 해당 위젯을 추가한다.(보이게 설정)&lt;/li&gt;
  &lt;li&gt;Widget-&amp;gt;Remove from Parent : 해당 위젯을 화면(Viewport)에서 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fovfield-of-view-조정&quot;&gt;FOV(Field Of View) 조정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Camera -&amp;gt; Set Field Of View : 카메라의 뷰 각도를 업데이트할 수 있는 함수.&lt;/li&gt;
  &lt;li&gt;Timeline 함수 : 특정 시간동안 FOV 값을 애니메이션화 하여 업데이트 할 수 있게 도와주는 함수.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;피탄-이펙트&quot;&gt;피탄 이펙트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Ray Casting : 총알의 시작점과 끝점 사이에 존재하는 물체들을 검사한 후, 그 중 시작점에서 가장 가까운 물체를 리턴해준다.
 -&amp;gt; 언리얼 엔진에서는 Line Trace라고함.&lt;/li&gt;
  &lt;li&gt;기본적으로 FPS 게임에서는 LineTrace의 시작점은 총구의 끝이 아닌, CrossHair를 기준으로 간다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;언리얼의 기준에서 CrossHair를 기준으로 잡을 경우, 그 기준은 SpringArm이라고 보면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Get Control Location : 사용자의 위치를 리턴받는 함수.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get Forward Vector : 입력값을 벡터로 변환해주는 함수.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Complex Collision : 복합 컬리전. 폴리곤을 사용하여 표면을 정확하게 감싸는 컬리전.&lt;/li&gt;
  &lt;li&gt;Break Hit Result : LineTrace의 리턴값 중 하나로, 구조체의 변수값 하나하나 직접 접근하고 싶을 때 사용.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Impact Point : 맞은 장소 리턴.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Apply Damage : 액터에게 데미지를 넘겨줄 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnyDamage : Apply Damage 함수에서 피격된 액터(Damaged Actor)의 AnyDamage 이벤트가 호출됨.
이곳의 파라미터들은 앞쪽에서 줬던 Apply Damage 함수에서 선언한 파라미터들을 그대로 받아오는 것.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;화면의 카메라 정보는 Controller에 저장되어있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Apply POintDamage만 호출해도 AnyDamage도 같이 호출된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;랙돌ragdoll-세팅&quot;&gt;랙돌(Ragdoll) 세팅.&lt;/h2&gt;

&lt;h2 id=&quot;부분-랙돌ragdoll-세팅&quot;&gt;부분 랙돌(Ragdoll) 세팅.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Set All bodies below Simulate Physics&lt;/li&gt;
  &lt;li&gt;In Bone Name : 해당 액터의 Skeleton에 저장된 뼈 이름을 기준으로 컨트롤 하고 싶은 부분의 이름을 입력한다.&lt;/li&gt;
  &lt;li&gt;Set All bodies below Physics Blend Weight&lt;/li&gt;
  &lt;li&gt;Physics Blend Weight : 0~1사이의 값을 입력&lt;/li&gt;
  &lt;li&gt;값이 0인 경우, 애니메이션 포즈만 쓰겠다.&lt;/li&gt;
  &lt;li&gt;값이 1인 경우, 랙돌 계산 후 랙돌 포즈만 쓰겠다.&lt;/li&gt;
  &lt;li&gt;값이 0.5인 경우, 애니메이션 포즈 반, 랙돌 포즈 반씩 섞어 사용.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/08/add-weapon-process.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/08/add-weapon-process.html</guid>
        
        <category>Socket</category>
        
        <category>Weapon</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine LandScape에 대해서..</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최종 수정일 : 2018-04-18&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;랜드스케이프란&quot;&gt;랜드스케이프란?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;임의로 만들어진 모양의 그리드 3D 모델&lt;/li&gt;
  &lt;li&gt;X,Y 값 자동 계산(내가 건들수없음)&lt;/li&gt;
  &lt;li&gt;높이(Z) 값만 조각 기능을 통해서 제공&lt;/li&gt;
  &lt;li&gt;버텍스 사이의 길이는 100 -&amp;gt; Scale값, 단위는 cm&lt;/li&gt;
  &lt;li&gt;연두색으로 나뉘어 있는 큰 단위는 Section&lt;/li&gt;
  &lt;li&gt;Component는 Section의 모임&lt;/li&gt;
  &lt;li&gt;Number Of Component : 한 랜드스케이프에 들어가는 컴포넌트의 갯수&lt;/li&gt;
  &lt;li&gt;정리&lt;/li&gt;
  &lt;li&gt;한개의 랜드스케이프에 여러개의 컴포넌트가 들어가고,&lt;/li&gt;
  &lt;li&gt;한개의 컴포넌트에 여러개의 섹션이 포함되어있으며,&lt;/li&gt;
  &lt;li&gt;한개의 섹션은 여러개의 버텍스로 이루어진다.&lt;/li&gt;
  &lt;li&gt;랜드스케이프 하나당 최대 길이는 8.161Km&lt;/li&gt;
  &lt;li&gt;Section Per Component -&amp;gt; 한 컴포넌트에 몇개의 섹션을 지정할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;layer-info-object&quot;&gt;Layer Info Object&lt;/h2&gt;
&lt;p&gt;랜드스케이프 레이어에 대한 정보가 들어있는 에셋.
어느 지역에 얼마만큼의 강도로 텍스쳐를 칠할지의 강도&lt;/p&gt;

&lt;h2 id=&quot;lod란&quot;&gt;LOD란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Level Of Detail의 약자&lt;/li&gt;
  &lt;li&gt;플레이어를 기준으로 플레이어가 대상 스태틱 매쉬에 멀어지면 해당 매쉬를 덜 복잡한 버전 또는 보이지 않게끔 하여 레벨 퍼포먼스를 높이는 기술&lt;/li&gt;
  &lt;li&gt;.FBX로 저장된 매쉬로 구현.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;폴리지-시스템&quot;&gt;폴리지 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;랜드스케이프에서 텍스쳐링 하듯 스태틱 매쉬를 렌더링 할 수 있는 시스템&lt;/li&gt;
  &lt;li&gt;스태틱 매쉬들 간의 Z fighting이 일어나지 않게 조정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;폴리지-타입&quot;&gt;폴리지 타입&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;align to normal -&amp;gt; 지형에 따라 폴리지를 어떻게 배치할 것인가?(나무는 꺼주고 잔디는 켜주는게 일반적)&lt;/li&gt;
  &lt;li&gt;Random Yaw -&amp;gt; 스태틱 매쉬가 바라보는 방향&lt;/li&gt;
  &lt;li&gt;Cull Distance -&amp;gt; 개활지의 경우 로딩을 어디까지(거리) 할 것인가?&lt;/li&gt;
  &lt;li&gt;컬리전 프리셋 -&amp;gt; 충돌 처리&lt;/li&gt;
  &lt;li&gt;LandScape Layers -&amp;gt; 특정 랜드스케이프에만 추가할 수 있게 하는 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로시저럴-함수&quot;&gt;프로시저럴 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단순한 절차적 생성 텍스처와 마스크를 빠프게 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;임포트된 텍스처에 비해 메모리가 절약된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Procedural Foliage Volume&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Procedural -&amp;gt; Collsion Radius : 나무들 간의 사이 거리&lt;/li&gt;
  &lt;li&gt;Procedural -&amp;gt; shade Radius : 일단 스킵&lt;/li&gt;
  &lt;li&gt;Procedural Foliage Blocking Volume -&amp;gt; 폴리지를 다시 시뮬레이션을 눌러도 폴리지 타입이 생성되는 것을 방지한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스트리밍-레벨&quot;&gt;스트리밍 레벨&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(작은 폴리지를 관리할 때 사용하는 것)퍼시스턴트 레벨의 자식 레벨, 퍼시스턴트가 살아있는 한, 메모리에 올렸다 내리는 것이 자연스러운 레벨&lt;/li&gt;
  &lt;li&gt;효율적인 메모리 관리가 가능&lt;/li&gt;
  &lt;li&gt;퍼시스턴트 레벨과 시공간을 공유.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;current-level현재-레벨&quot;&gt;Current Level(현재 레벨)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;액터를 추가할 때, 액터가 추가되는 맵의 레벨&lt;/li&gt;
  &lt;li&gt;레벨 창에서 파란색으로 이름이 표시되있는 것이 현재 레벨&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;level-bounds레벨-바운드&quot;&gt;Level Bounds(레벨 바운드)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스트리밍 레벨이 퍼시스턴트 레벨에서 어느정도 범위를 가지고 있는지 미리 계산을 해서 박스의 형태로 가지고 있는 것&lt;/li&gt;
  &lt;li&gt;폴리지는 액터 취급을 안해줌&lt;/li&gt;
  &lt;li&gt;레벨 바운드의 범위(streaming distance)를 직접 지정해주고 싶을 경우 레벨 탭의 월드 컴포지션으로 들어감.&lt;/li&gt;
  &lt;li&gt;하나의 레벨 바운드는 하나의 레이어만 할당할 수 있다.(1:1 관계)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;world-composition월드-컴포지션&quot;&gt;World Composition(월드 컴포지션)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스트리밍 레벨이 어떻게 나뉘어있는지 한눈에 볼 수 있는 툴&lt;/li&gt;
  &lt;li&gt;레이어를 새로 생성해서 커스텀할 경우 스트리밍 거리를 커스텀 할 수 있다.&lt;/li&gt;
  &lt;li&gt;레이어는 수정 기능이 없음.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나도 세팅되지 못한 레이어는 나중에 자동적으로 삭제됨.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[참조]언리얼엔진이 아닌, 맵을 구성할 때 사용하면 유용한 이미지 툴&lt;/li&gt;
  &lt;li&gt;월드 머신 / 월드 크리에이터 (유료 버전만 존재)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Wysilab - Instant Terra : 무료 트라이얼&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Height Map : 버텍스 하나를 그림파일로 대응시키는 방식&lt;/li&gt;
  &lt;li&gt;흰색 : 최고 높은 지형의 색&lt;/li&gt;
  &lt;li&gt;검은색 : 최고 낮은 지형의 색&lt;/li&gt;
  &lt;li&gt;Height가 0~255 일 때, Import하면 -256&lt;em&gt;(Scale Z축의 값)~256&lt;/em&gt;(Scale Z축의 값)으로 임포트됨&lt;/li&gt;
  &lt;li&gt;Scale = Instant Terra Range값 / 512(언리얼엔진 값 범위 [상수])
// FOB&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/08/about-land-scape.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/08/about-land-scape.html</guid>
        
        <category>Actor</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Possess에 대해서..</title>
        <description>&lt;h1 id=&quot;possess-&quot;&gt;Possess &lt;빙의&gt;&lt;/빙의&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;맵 상에 존재하는 Pawn을 지목하여 플레이어 컨트롤러가 처리하지 않는 키를 Pawn에게 전달하는 행위&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mesh--캐릭터의-겉모습을-표현해주는-버텍스&quot;&gt;mesh = 캐릭터의 겉모습을 표현해주는 버텍스,&lt;/h2&gt;
&lt;h2 id=&quot;animation-data--캐릭터의-애니메이션을-표현해주는-데이터&quot;&gt;animation data = 캐릭터의 애니메이션을 표현해주는 데이터&lt;/h2&gt;
&lt;h2 id=&quot;fbs-file---unreal-import&quot;&gt;fbs file -&amp;gt; unreal import&lt;/h2&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-possess.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-possess.html</guid>
        
        <category>Possess</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine LandScape에 대해서..</title>
        <description>&lt;h1 id=&quot;랜드스케이프란&quot;&gt;랜드스케이프란?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;임의로 만들어진 모양의 그리드 3D 모델&lt;/li&gt;
  &lt;li&gt;X,Y 값 자동 계산(내가 건들수없음)&lt;/li&gt;
  &lt;li&gt;높이(Z) 값만 조각 기능을 통해서 제공&lt;/li&gt;
  &lt;li&gt;버텍스 사이의 길이는 100 -&amp;gt; Scale값, 단위는 cm&lt;/li&gt;
  &lt;li&gt;연두색으로 나뉘어 있는 큰 단위는 Section&lt;/li&gt;
  &lt;li&gt;Component는 Section의 모임&lt;/li&gt;
  &lt;li&gt;Number Of Component : 한 랜드스케이프에 들어가는 컴포넌트의 갯수&lt;/li&gt;
  &lt;li&gt;정리&lt;/li&gt;
  &lt;li&gt;한개의 랜드스케이프에 여러개의 컴포넌트가 들어가고,&lt;/li&gt;
  &lt;li&gt;한개의 컴포넌트에 여러개의 섹션이 포함되어있으며,&lt;/li&gt;
  &lt;li&gt;한개의 섹션은 여러개의 버텍스로 이루어진다.&lt;/li&gt;
  &lt;li&gt;랜드스케이프 하나당 최대 길이는 8.161Km&lt;/li&gt;
  &lt;li&gt;Section Per Component -&amp;gt; 한 컴포넌트에 몇개의 섹션을 지정할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;layer-info-object&quot;&gt;Layer Info Object&lt;/h2&gt;
&lt;p&gt;랜드스케이프 레이어에 대한 정보가 들어있는 에셋.
어느 지역에 얼마만큼의 강도로 텍스쳐를 칠할지의 강도&lt;/p&gt;

&lt;h2 id=&quot;lod란&quot;&gt;LOD란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Level Of Detail의 약자&lt;/li&gt;
  &lt;li&gt;플레이어를 기준으로 플레이어가 대상 스태틱 매쉬에 멀어지면 해당 매쉬를 덜 복잡한 버전 또는 보이지 않게끔 하여 레벨 퍼포먼스를 높이는 기술&lt;/li&gt;
  &lt;li&gt;.FBX로 저장된 매쉬로 구현.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;폴리지-시스템&quot;&gt;폴리지 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;랜드스케이프에서 텍스쳐링 하듯 스태틱 매쉬를 렌더링 할 수 있는 시스템&lt;/li&gt;
  &lt;li&gt;스태틱 매쉬들 간의 Z fighting이 일어나지 않게 조정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;폴리지-타입&quot;&gt;폴리지 타입&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;align to normal -&amp;gt; 지형에 따라 폴리지를 어떻게 배치할 것인가?(나무는 꺼주고 잔디는 켜주는게 일반적)&lt;/li&gt;
  &lt;li&gt;Random Yaw -&amp;gt; 스태틱 매쉬가 바라보는 방향&lt;/li&gt;
  &lt;li&gt;Cull Distance -&amp;gt; 개활지의 경우 로딩을 어디까지(거리) 할 것인가?&lt;/li&gt;
  &lt;li&gt;컬리전 프리셋 -&amp;gt; 충돌 처리&lt;/li&gt;
  &lt;li&gt;LandScape Layers -&amp;gt; 특정 랜드스케이프에만 추가할 수 있게 하는 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로시저럴-함수&quot;&gt;프로시저럴 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단순한 절차적 생성 텍스처와 마스크를 빠프게 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;임포트된 텍스처에 비해 메모리가 절약된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Procedural Foliage Volume&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Procedural -&amp;gt; Collsion Radius : 나무들 간의 사이 거리&lt;/li&gt;
  &lt;li&gt;Procedural -&amp;gt; shade Radius : 일단 스킵&lt;/li&gt;
  &lt;li&gt;Procedural Foliage Blocking Volume -&amp;gt; 폴리지를 다시 시뮬레이션을 눌러도 폴리지 타입이 생성되는 것을 방지한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스트리밍-레벨&quot;&gt;스트리밍 레벨&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(작은 폴리지를 관리할 때 사용하는 것)퍼시스턴트 레벨의 자식 레벨, 퍼시스턴트가 살아있는 한, 메모리에 올렸다 내리는 것이 자연스러운 레벨&lt;/li&gt;
  &lt;li&gt;효율적인 메모리 관리가 가능&lt;/li&gt;
  &lt;li&gt;퍼시스턴트 레벨과 시공간을 공유.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;current-level현재-레벨&quot;&gt;Current Level(현재 레벨)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;액터를 추가할 때, 액터가 추가되는 맵의 레벨&lt;/li&gt;
  &lt;li&gt;레벨 창에서 파란색으로 이름이 표시되있는 것이 현재 레벨&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;level-bounds레벨-바운드&quot;&gt;Level Bounds(레벨 바운드)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스트리밍 레벨이 퍼시스턴트 레벨에서 어느정도 범위를 가지고 있는지 미리 계산을 해서 박스의 형태로 가지고 있는 것&lt;/li&gt;
  &lt;li&gt;폴리지는 액터 취급을 안해줌&lt;/li&gt;
  &lt;li&gt;레벨 바운드의 범위(streaming distance)를 직접 지정해주고 싶을 경우 레벨 탭의 월드 컴포지션으로 들어감.&lt;/li&gt;
  &lt;li&gt;하나의 레벨 바운드는 하나의 레이어만 할당할 수 있다.(1:1 관계)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;world-composition월드-컴포지션&quot;&gt;World Composition(월드 컴포지션)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스트리밍 레벨이 어떻게 나뉘어있는지 한눈에 볼 수 있는 툴&lt;/li&gt;
  &lt;li&gt;레이어를 새로 생성해서 커스텀할 경우 스트리밍 거리를 커스텀 할 수 있다.&lt;/li&gt;
  &lt;li&gt;레이어는 수정 기능이 없음.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나도 세팅되지 못한 레이어는 나중에 자동적으로 삭제됨.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[참조]언리얼엔진이 아닌, 맵을 구성할 때 사용하면 유용한 이미지 툴&lt;/li&gt;
  &lt;li&gt;월드 머신 / 월드 크리에이터 (유료 버전만 존재)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Wysilab - Instant Terra : 무료 트라이얼&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Height Map : 버텍스 하나를 그림파일로 대응시키는 방식&lt;/li&gt;
  &lt;li&gt;흰색 : 최고 높은 지형의 색&lt;/li&gt;
  &lt;li&gt;검은색 : 최고 낮은 지형의 색&lt;/li&gt;
  &lt;li&gt;Height가 0~255 일 때, Import하면 -256&lt;em&gt;(Scale Z축의 값)~256&lt;/em&gt;(Scale Z축의 값)으로 임포트됨&lt;/li&gt;
  &lt;li&gt;Scale = Instant Terra Range값 / 512(언리얼엔진 값 범위 [상수])
// FOB&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-land-scape.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-land-scape.html</guid>
        
        <category>Actor</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine System에 대해서..</title>
        <description>&lt;h1 id=&quot;unreal-engine-4-game-system&quot;&gt;Unreal Engine 4 Game System.&lt;/h1&gt;

&lt;h2 id=&quot;game-mode&quot;&gt;Game Mode&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;게임에 영향을 미치는 가장 중요한 규칙을 구현하는 액터&lt;/li&gt;
  &lt;li&gt;게임 서버의 역할을 한다고 봄.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hud--게임-ui를-렌더링하는-액터&quot;&gt;HUD : 게임 UI를 렌더링하는 액터&lt;/h3&gt;

&lt;h3 id=&quot;playerstate--남들이-알아야-하는-내-정보를-저장하는-액터&quot;&gt;PlayerState : 남들이 알아야 하는 내 정보를 저장하는 액터&lt;/h3&gt;

&lt;h3 id=&quot;gamestate--게임에-공통된-정보를-동기화-시킬-때-저장하는-장소로-사용하는-액터&quot;&gt;GameState : 게임에 공통된 정보를 동기화 시킬 때 저장하는 장소로 사용하는 액터&lt;/h3&gt;

&lt;p&gt;// 참고 .. 데디케이트 서버 : 클라이언트가 없고 게임 로직만 돌아가는 서버&lt;/p&gt;

&lt;p&gt;// 맵 이동을 하게 되면, 게임 모드와 플레이어 컨트롤러가 날라간다(삭제 후 재호출).
// 게임 스테이트, 플레이어 스테이트, 폰 모두 날라감&lt;/p&gt;

&lt;h2 id=&quot;레벨간의-데이터를-주고-받을-수-있는-방법&quot;&gt;레벨간의 데이터를 주고 받을 수 있는 방법&lt;/h2&gt;

&lt;h3 id=&quot;game-instance-class--게임이-처음-실행-될-때-생성된-후-게임이-종료될-때-destroy&quot;&gt;Game Instance Class : 게임이 처음 실행 될 때 생성된 후, 게임이 종료될 때 destroy&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;project setting -&amp;gt; map &amp;amp; mod -&amp;gt; game default map : 게임 실행 파일을 실행했을 때 제일 처음 실행될 맵(보통 인트로 or 로그인)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-engine-system.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-engine-system.html</guid>
        
        <category>System</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Character에 대해서..</title>
        <description>&lt;h1 id=&quot;character-&quot;&gt;Character &lt;캐릭터&gt;&lt;/캐릭터&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Skeletal mesh - Bone이 있는 mesh&lt;/li&gt;
  &lt;li&gt;스태틱매쉬 : Bone이 없는 mesh » skeletal mesh옵션 off&lt;/li&gt;
  &lt;li&gt;import mesh - 버텍스와 폴리곤 정보를 임포트 할 것인가? -&amp;gt;off 할 경우에는 애니메이션만 가져오겠다는 표현.&lt;/li&gt;
  &lt;li&gt;import Material : 보통은 off 시킴&lt;/li&gt;
  &lt;li&gt;import texture : 보통 off 시킴&lt;/li&gt;
  &lt;li&gt;PhysicsAsset : 본마다 컬리젼을 만들어준 것&lt;/li&gt;
  &lt;li&gt;Skeletal Mesh : 캐릭터의 버텍스, 폴리곤 정보&lt;/li&gt;
  &lt;li&gt;Skeleton : 캐릭터의 뼈 구조를 확인 할 수 있는 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;capsulecomponent--root-component--캐릭터의-충돌-처리나-이동은-캡슐-컴포넌트를-활용&quot;&gt;CapsuleComponent : Root Component / 캐릭터의 충돌 처리나 이동은 캡슐 컴포넌트를 활용&lt;/h2&gt;
&lt;h2 id=&quot;arrow-component--캐릭터의-진행방향을-나타내주는-방향&quot;&gt;Arrow Component : 캐릭터의 진행방향을 나타내주는 방향&lt;/h2&gt;
&lt;h2 id=&quot;mesh--스캘레탈-매쉬-컴포넌트--이거-외에도-원한다면-스켈레탈-매쉬를-추가할-수-있음&quot;&gt;Mesh : 스캘레탈 매쉬 컴포넌트 / 이거 외에도 원한다면 스켈레탈 매쉬를 추가할 수 있음.&lt;/h2&gt;
&lt;p&gt;// 줄 : Scene Component와 Actor Component를 구분짓는 선&lt;/p&gt;

&lt;h2 id=&quot;character-movement--캐릭터-이동에-관련된-기능들이-들어있음-네트워킹-기능이-구현이-되어있음-멀티플레이어-시-캐릭터-이동을-부드럽게-보간해주는-기능이-들어있음-오직-캐릭터-클래스에만-들어가있음--게이머가-바라보고-있는-방향에-영향을-받음&quot;&gt;Character Movement : 캐릭터 이동에 관련된 기능들이 들어있음. 네트워킹 기능이 구현이 되어있음. 멀티플레이어 시 캐릭터 이동을 부드럽게 보간해주는 기능이 들어있음. 오직 캐릭터 클래스에만 들어가있음. / 게이머가 바라보고 있는 방향에 영향을 받음.&lt;/h2&gt;

&lt;p&gt;//마우스 입력값을 받았을 때 플레이어 컨트롤러에 입력값을 저장.&lt;/p&gt;

&lt;h2 id=&quot;add-controller-yaw-input--pawn의-플레이어-컨트롤러를-찾아서-x회전값을-누적시켜서-카메라의-절대-회전값을-변환-시켜준다&quot;&gt;add controller yaw input : pawn의 플레이어 컨트롤러를 찾아서, x회전값을 누적시켜서 카메라의 절대 회전값을 변환 시켜준다.&lt;/h2&gt;
&lt;h2 id=&quot;add-controller-pitch-input--pawn의-플레이어-컨트롤러를-찾아서-y회전값을-누적시켜서-카메라의-절대-회전값을-변환-시켜준다&quot;&gt;add controller pitch input : pawn의 플레이어 컨트롤러를 찾아서, y회전값을 누적시켜서 카메라의 절대 회전값을 변환 시켜준다.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;둘 다 카메라를 직접 회전시켜주는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;springarm--use-pawn-control-rotation--플레이어-컨트롤러에-로테이션을-사용하겠다&quot;&gt;SpringArm : Use pawn control Rotation : 플레이어 컨트롤러에 로테이션을 사용하겠다.&lt;/h2&gt;
&lt;h2 id=&quot;inherit-roll--카메라가-마치-롤러-코스터처럼-회전하는-방식&quot;&gt;Inherit Roll : 카메라가 마치 롤러 코스터처럼 회전하는 방식.&lt;/h2&gt;

&lt;h2 id=&quot;axis-가상키--키의-입력이-없어도-매-프레임마다-호출이-된다&quot;&gt;axis 가상키 : 키의 입력이 없어도 매 프레임마다 호출이 된다.&lt;/h2&gt;

&lt;h2 id=&quot;add-input-vector--캐릭터가-어느방향으로-이동하고-싶은지-방향을-알려주는-함수-방향은-월드-축을-기준으로-알려줌&quot;&gt;add input vector : 캐릭터가 어느방향으로 이동하고 싶은지 방향을 알려주는 함수. 방향은 월드 축을 기준으로 알려줌.&lt;/h2&gt;
&lt;h2 id=&quot;get-control-rotation--컨트롤러의-로테이션을-가져오는-함수&quot;&gt;Get Control Rotation : 컨트롤러의 로테이션을 가져오는 함수&lt;/h2&gt;
&lt;h2 id=&quot;get-forward-vector--내가-바라보고-있는-방향을-벡터로-변환&quot;&gt;Get Forward Vector : 내가 바라보고 있는 방향을 벡터로 변환&lt;/h2&gt;
&lt;h2 id=&quot;상수--벡터--부호를-곱해줘서-앞인지-뒤인지-확인&quot;&gt;상수 * 벡터 : 부호를 곱해줘서 앞인지 뒤인지 확인.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Yaw, Pitch, Roll에 대해 외우는 소소한 팁…&lt;/li&gt;
  &lt;li&gt;Yaw : Yaw리조리 두리번두리번&lt;/li&gt;
  &lt;li&gt;Pitch : 끄덕끄덕(피.. 알았어)&lt;/li&gt;
  &lt;li&gt;Roll : 롤러코스터 전방 360도 회전&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;한-프레임-내에-add-input-vector가-여러번-호출되도-character-movement에서-한번에-취합해서-처리한-후-최종-월드-vector에-대해-처리하기-때문에-상관없음&quot;&gt;한 프레임 내에 Add Input Vector가 여러번 호출되도 Character Movement에서 한번에 취합해서 처리한 후 최종 월드 Vector에 대해 처리하기 때문에 상관없음.&lt;/h2&gt;

&lt;h2 id=&quot;animation-sequence--반복되는-하나의-동작&quot;&gt;Animation Sequence : 반복되는 하나의 동작&lt;/h2&gt;
&lt;h2 id=&quot;animation-blueprint&quot;&gt;Animation BluePrint&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;try get pawn owner : 이 블루프린트를 쓰고 있는 pawn을 가져올 수 있다.&lt;/li&gt;
  &lt;li&gt;다른 쓰레드에서 돌기때문에 변수를 공유해서 쓸수 없으므로, 새로 변수를 선언해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;blend-space-1d--변수-하나의-값에-따라서-어떤-시퀀스를-실행을-해줄지-선택해주는-에셋&quot;&gt;Blend space 1D : 변수 하나의 값에 따라서 어떤 시퀀스를 실행을 해줄지 선택해주는 에셋.&lt;/h2&gt;

&lt;h2 id=&quot;state-machine--상태기계-안에-여러가지-state행동이-존재&quot;&gt;State Machine : 상태기계 안에 여러가지 State(행동)이 존재&lt;/h2&gt;

&lt;h2 id=&quot;animation-blueprint-bond-transform-rotation-rotation-mode&quot;&gt;Animation BluePrint-&amp;gt;Bond Transform-&amp;gt;Rotation-&amp;gt;Rotation Mode&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Replace Existing : 기존 회전값 무시&lt;/li&gt;
  &lt;li&gt;Add to Existing : 기존 회전값 +@&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;중첩된-상태기계&quot;&gt;중첩된 상태기계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;많은 애니메이션을 표현할 때 bool로 포즈를 블렌딩 하는 함수보다 효율적.&lt;/li&gt;
  &lt;li&gt;가장 큰 상태를 먼저 정의한 후,&lt;/li&gt;
  &lt;li&gt;각각의 상태에 들어가서 또 다시 작은 상태를 정의&lt;/li&gt;
  &lt;li&gt;그 안에서 분기에 따른 애니메이션을 부여한다.&lt;/li&gt;
  &lt;li&gt;처음엔 어려울 수 있으나, 적응되면 나중에 많은 애니메이션을 관리할 때 더욱 수월하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;notify&quot;&gt;Notify&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션이나 시퀀스가 진행이 될 때 특정 타이밍에 애니메이션 블루프린트에게 이벤트를 던져 줄 수 있다.&lt;/li&gt;
  &lt;li&gt;역으로 애니메이션 블루프린트가 Pawn에게도 알려줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;점프&quot;&gt;점프&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐릭터가 땅에 닿았는지 떨어져있는지는 CapsuleComponent를 기준으로 확인&lt;/li&gt;
  &lt;li&gt;isFalling 함수도 CapsuleComponent를 기준으로 삼음. (땅에 떨어져 있으면 true, 붙어있으면 false)&lt;/li&gt;
  &lt;li&gt;isFalling은 애니메이션 무브먼트에서도 접근이 가능하기 때문에 따로 변수로 승격시키지 않아도 됨.&lt;/li&gt;
  &lt;li&gt;애님몽타쥬의 애니메이션 슬롯을 어떤 것을 사용할 지 정하는 곳은 ‘애님몽타쥬’에 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-character.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-character.html</guid>
        
        <category>Character</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Animation에 대해서..</title>
        <description>&lt;h1 id=&quot;애니메이션&quot;&gt;애니메이션&lt;/h1&gt;

&lt;h2 id=&quot;애니메이션-몽타주&quot;&gt;애니메이션 몽타주&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Asset의 일종&lt;/li&gt;
  &lt;li&gt;여러개의 시퀀스를 합쳐서 재생시켜주는 기능&lt;/li&gt;
  &lt;li&gt;시작 , 루프, 끝 애니메이션을 나눠서 섹션 구간별 이벤트를 발생시킬 수 있는 섹션 기능&lt;/li&gt;
  &lt;li&gt;애니메이션 몽타주가 실행되기 이전의 애니메이션 포즈들을 모두 삭제 후, 애니메이션 몽타주에 저장되있는 애니메이션들을 사용한다.&lt;/li&gt;
  &lt;li&gt;일정 타이밍에 소리를 출력하거나, 이펙트를 출력하는 기능&lt;/li&gt;
  &lt;li&gt;커스텀 커브 기능&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pawn이 애니메이션 블루프린트한테 바로 명령을 내릴 수 있다&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로세스 : 애니메이션 몽타주 생성 -&amp;gt; 스켈레톤 선택 -&amp;gt; 몽타쥬에 원하는 애니메이션을 정의 후, 캐릭터 블루프린트에서 해당 이벤트가 발생했을 경우 skeletal mesh를 통해서 애니메이션 블루프린트를 가져와서 montage play 함수를 호출한다. -&amp;gt; 애니메이션 블루프린트로 가서 애니메이션 컴포넌트를 최종 애니메이션 포즈로 입력하는 사이에 Montage의 DefaultSlot을 통과하게 중간에 배치한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 포즈 새로 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;함수&quot;&gt;함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Skeletal Mesh -&amp;gt; Get Anim Instance : 스켈레탈 매쉬에 있는 애니메이션 블루프린트를 가져온다.&lt;/li&gt;
  &lt;li&gt;Get Anim Instance -&amp;gt; Montage Play : 생성해놓은 애니메이션 몽타주를 실행한다.&lt;/li&gt;
  &lt;li&gt;본 마다 레이어로 블렌딩 -&amp;gt; Mesh Space Rotation : 본의 좌표 기준으로 할 것인지, 컴포넌트 스페이스 기준으로 할 것인지 정하는 옵션&lt;/li&gt;
  &lt;li&gt;Spawn Emitter Attached :&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-animation.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-animation.html</guid>
        
        <category>Animation</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Actor에 대해서..</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최종 수정일 : 2018-04-18&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;액터의-정의&quot;&gt;액터의 정의&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;월드는 언리얼에서 제공하는 한 프로젝트의 구성 공간을 의미하며, 게임에서 흔히 말하는 맵을 표현.&lt;/li&gt;
  &lt;li&gt;월드는 프로젝트당 한개만 존재한다.&lt;/li&gt;
  &lt;li&gt;월드에는 캐릭터, 몬스터, 배경 등 수많은 오브젝트들이 존재하는데, 이것들을 전부 액터라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;액터--월드레벨를-꾸며주는-모든-컴포넌트-또는-리플리케이션의-단위&quot;&gt;액터 : 월드(레벨)를 꾸며주는 모든 컴포넌트 또는 리플리케이션의 단위&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;리플리케이션(Replication) : 네트워크 게임에서 서로 동기화하는 작업&lt;/li&gt;
  &lt;li&gt;그러므로 액터의 직렬화를 통해서 네트워크 데이터 동기화의 기능을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진은 모든 단위를 액터로 통제한다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진을 사용함에 있어 가장 중요한 클래스.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 액터가 물체 또는 형태를 가지고 있는 것은 아니다.(ex. Player Controller, Game Mode)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;레벨 : 게임에서의 맵을 표현하는 언리얼엔진의 단위&lt;/li&gt;
  &lt;li&gt;스폰 : 월드(또는 레벨)에 액터를 실시간으로 추가하는 행위 / 월드 상에 액터 클래스를 전달받아서 액터 클래스에 맞는 새로운 오브젝트를 만드는 행위&lt;/li&gt;
  &lt;li&gt;박스 트리거 : 특정 지점에 캐릭터가 진입할 경우 이벤트를 발생시킬 수 있는 지점을 만드는 액터(인게임에 들어갔을 때 트리거는 따로 보여지진 않는다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기초적인-액터-개념에-대해서-살펴보자&quot;&gt;기초적인 액터 개념에 대해서 살펴보자&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;액터 클래스&lt;/li&gt;
  &lt;li&gt;레벨에 배치되거나 스폰 될 수 있는 객체의 기본 클래스.&lt;/li&gt;
  &lt;li&gt;액터 내부에는 액터의 이동 방법, 렌더링 방법 등을 제어하는 데 사용할 수 있는 ActorComponents Collections가 포함되어 있다.&lt;/li&gt;
  &lt;li&gt;컨텐츠 브라우저에서 우리가 원하는 커스텀 액터 클래스를 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;개별적인 에셋으로 존재하거나 엔진에 내장되어 있다.&lt;/li&gt;
  &lt;li&gt;플레이 중 네트워크에서 속성 및 기능 함수 호출을 복제하는 기능도 포함되어 있다.&lt;/li&gt;
  &lt;li&gt;액터는 기능을 담당하는 컴포넌트들을 담아서 사용하는 그릇이라고 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;레벨 안에서의 최소 커뮤니케이션 단위는 액터 안에서의 상호작용으로 일어난다.&lt;/li&gt;
  &lt;li&gt;클래스이기 때문에 함수와 변수를 소유할 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;구체적인 개별 에셋들을 만들 때는 액터에 그에 맞는 컴포넌트를 추가한 후 에셋을 추가해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;액터 오브젝트&lt;/li&gt;
  &lt;li&gt;액터 클래스를 월드에 생성한 인스턴스를 지칭함.&lt;/li&gt;
  &lt;li&gt;액터 오브젝트는 월드 아웃라이너 탭에서 생성됬는지 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;액터 오브젝트는 Level Asset에 나열되서 저장된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;스폰 Spawn&lt;/li&gt;
  &lt;li&gt;액터를 월드(레벨)에 생성하는 행위&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;액터 클래스를 월드에 인스턴스를 생성하는 것을 의미함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;블루프린트 클래스&lt;/li&gt;
  &lt;li&gt;부모 클래스 : 선택한 클래스를 상속받는 액터 클래스를 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부모 클래스의 최상위 클래스는 액터 클래스이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pawn&lt;/li&gt;
  &lt;li&gt;액터를 상속 받아서 만든 클래스&lt;/li&gt;
  &lt;li&gt;플레이어나 AI가 제어할 수 있는 모든 액터의 베이스 클래스.&lt;/li&gt;
  &lt;li&gt;월드 내 플레이어나 AI 개체에 대한 물리적 표현.&lt;/li&gt;
  &lt;li&gt;플레이어의 시각적인 모습 뿐만 아니라, Collision이나 기타 물리적 반응과 같은 측면에서 월드와의 상호작용 방식을 규정.&lt;/li&gt;
  &lt;li&gt;게임 내 플레이어의 물리적 위치, 방향등을 나타냄.&lt;/li&gt;
  &lt;li&gt;Controller와 Pawn은 1:1 대응 관계.(무슨 일이 있어도 각 Controller는 하나의 Pawn만 제어한다.)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;게임 플레이 도중 스폰된 Pawn이 자동적으로 Controller에 Possess되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Character&lt;/li&gt;
  &lt;li&gt;Pawn을 상속 받아서 만든 클래스&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;걸어다닐 수 있는 능력을 지닌 특수 유형 Pawn.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Player Controller&lt;/li&gt;
  &lt;li&gt;클라이언트의 느낌을 많이 받음&lt;/li&gt;
  &lt;li&gt;사용자의 키 입력을 받는다.&lt;/li&gt;
  &lt;li&gt;UI 처리를 담당하는 클래스&lt;/li&gt;
  &lt;li&gt;클라이언트에서 매 프레임마다 검사/체크 하는 로직을 구현하기 좋음&lt;/li&gt;
  &lt;li&gt;클라이언트의 메인 클래스&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;플레이어 컨트롤러가 Pawn을 조종한다.(1:1 대응 관계)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;컴포넌트&lt;/li&gt;
  &lt;li&gt;언리얼엔진은 엔진의 기능을 컴포넌트 단위로 액터에게 제공해준다.&lt;/li&gt;
  &lt;li&gt;액터는 기능별로 존재하진 않음. 액터의 기능을 담당하는 것이 컴포넌트&lt;/li&gt;
  &lt;li&gt;포인트라이트 액터에는 포인트라이트 컴포넌트만 들어가있는 액터&lt;/li&gt;
  &lt;li&gt;기능이 컴포넌트로 구분이 되어있는 것&lt;/li&gt;
  &lt;li&gt;하나의 액터 안에 여러개의 컴포넌트를 조합해서 나만의 액터를 만들 수도 있음.&lt;/li&gt;
  &lt;li&gt;액터 안에서 서로의 컴포넌트들이 상호작용을 이루게 됨.
    &lt;blockquote&gt;
      &lt;p&gt;언리얼에서 하는 코딩작업은 이벤트 중심의 게임 동작.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;스태틱 매쉬(Static Mesh)&lt;/li&gt;
  &lt;li&gt;애니메이션 되지 않는 매쉬들. 물체.&lt;/li&gt;
  &lt;li&gt;비디오 메모리에 캐시되고 그래픽 카드에 렌더링할 수 있는 폴리곤 세트로 구성되는 지오메트리 조각&lt;/li&gt;
  &lt;li&gt;비디오 메모리에 저장되기 때문에 위치, 방향, 크기를 조절할 수는 있지만, 어떤식으로든 그 버텍스를 움직일 수는 없다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레벨의 월드 지오메트리를 만드는 데 쓰이는 기본 단위&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;버텍스(Vertex)&lt;/li&gt;
  &lt;li&gt;하나의 ‘점’&lt;/li&gt;
  &lt;li&gt;정점이라 하며, 3D의 가장 기본단위&lt;/li&gt;
  &lt;li&gt;2D의 포인트와 대응되는 개념이지만, 정점은 위치, 색상, 법선 등 다양한 정보를 담고 있다.&lt;/li&gt;
  &lt;li&gt;버텍스와 포인트의 차이
    &lt;ul&gt;
      &lt;li&gt;포인트는 X, Y 좌표값만 가지고 있지만, 버텍스는 위치, 색상, 법선 등의 다양한 정보를 가지고있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;폴리곤(Polygon)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최소의 면단위 (최소 3개의 버텍스가 모여 만들어지는 하나의 면을 ‘폴리곤’이라고 한다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;메쉬 (Mesh)&lt;/li&gt;
  &lt;li&gt;폴리곤들이 모이면 최소한 3차원 공간상의 면을 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;폴리곤들이 모여 만들어진 3차원 공간산의 물체(Object) 이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사운드 웨이브 : 웨이브 파일(.wav)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사운드 큐 : 웨이브 파일을 몇개를 받아서 옵션을 걸어줄 수 있다.(여러개의 웨이브 파일을 한군데 묶는 기능)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Collision&lt;/li&gt;
  &lt;li&gt;물리학에서 두 물체가 서로의 운동에 간섭(충돌)하는 현상을 말한다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진에서는 액터와 액터 간의 충돌 현상을 처리하는 방식에 대해서 설정할 수 있다.&lt;/li&gt;
  &lt;li&gt;액터를 감싸고 있는 컬리전 컴포넌트를 통해서 액터간의 충돌이 일어났는지 여부를 판단한다.&lt;/li&gt;
  &lt;li&gt;단순 컬리전과 복합 컬리전 두가지로 존재한다.&lt;/li&gt;
  &lt;li&gt;스태틱 메시 에디터에서 세팅 옵션에 Collision Complexity(충돌 복잡도) 세팅에서 원하는 값을 세팅할 수 있다.&lt;/li&gt;
  &lt;li&gt;컬리전 옵션으로는 총 세가지가 존재한다.&lt;/li&gt;
  &lt;li&gt;Default : 기본 - 단순 컬리전 요청이 단순컬리전을, 복합 요청은 복합 컬리전을 사용하도록 하는 ‘기본’ 동작.&lt;/li&gt;
  &lt;li&gt;UseSimpleAsComplex : 단순을 복합으로 사용 - 복합 쿼리 요청시에도 엔진은 단순 모양에 대한 쿼리를
 계속, 기본적으로 트라이메시를 무시합니다. 트라이메시를 구울 필요가 없기에 메모리가 절약되고, 컬리전 지오메트리가
 단순해 지면 퍼포먼스가 향상될 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UseComplexAsSimple : 복합을 단순으로 사용 - 단순 쿼리 요청시에도 엔진은 복합 모양에 대한 쿼리를 계속,
 기본적으로 단순 컬리전을 무시합니다. 이를 통해 물리 시뮬레이션 컬리전에 트라이메시를 사용할 수 있습니다. 참고로
 UseComplexAsSimple 사용중인 경우 오브젝트 시뮬레이션은 불가능하나, 다른 시뮬레이션(단순) 오브젝트와의 충돌은 가능합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Construction Script : 새로운 액터 오브젝트를 만들 때 딱 한번 호출되는 함수. / 초기화&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;액터-이벤트&quot;&gt;액터 이벤트&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BeginPlay : 게임이 시작 될 때, BeginPlay가 정의가 된 액터들은 딱 한번만 호출한다.(초기화)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Construction Script : BeginPlay와 비슷하지만, 이 함수는 액터를 직접 배치할 때와 디테일의 값을 변경할 때 호출된다.(게임이 실행될 때는 호출하지않음.)
동적 스폰을 통해 생성할 때는 Construction Script -&amp;gt; BeginPlay가 호출된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Tick : 게임 시뮬레이션을 한번 돌 때마다 호출되는 함수. 지속적으로 값을 바꾸는 작업을 할 때 사용.&lt;/li&gt;
  &lt;li&gt;Tick 이벤트 : 틱당 계속 호출되는 이벤트&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;60 프레임 : 1초에 60번 계산을 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;End Play : 액터가 삭제 될 때 호출되는 이벤트&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EndPlayReason : 액터가 삭제되는 이유&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Collision OnComponent Begin Overlap : 액터가 충돌이 일어나는 시점에 발생하는 이벤트&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Collision OnComponent End Overlap : 액터가 충돌이 끝난 시점에 발생하는 이벤트&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ActorBeginOverlap : 내가 가지고 있는 하위 컴포넌트 중에 begin overlap이 발생하면, 같이 호출되는 이벤트&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Delay : 지정한 시간(Duration)동안 다음 노드로 가기 전까지 시간을 기다린 후 다음 노드를 진행하는 함수.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Custom Event : 엔진에서 제공하는 이벤트가 아닌, 프로그래머가 직접 이벤트를 생성하여 로직을 작성하여 원할 때 호출할 수 있도록 작성할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Deactivate : 기능 컴포넌트를 비활성화를 시키는 함수.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activate : 기능 컴포넌트를 활성화 시키는 함수.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Set Visibility : 물체가 레벨에 눈으로 볼 수 있도록 표현 되어있는 컴포넌트는 이를 통해서 보여지거나, 감출 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Propagate to Children : 해당 액터(또는 컴포넌트)의 자식 액터들까지 영향을 미치게 하는 기능.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OverLab : 액터의 컬리전들끼리 겹치는 현상을 말함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;SphereOverlapActors : 해당 액터 주위에 다른 액터가 있는지 검사할 수 있는 함수. 비슷한 함수로 Box, Capsule, ComponentOverlapActors가 있다.
    &lt;ul&gt;
      &lt;li&gt;Return 값은 boolean 값으로, 조건에 해당하는 액터가 있을 경우 true, 그렇지 않을 경우 false를 리턴.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-actor.html</link>
        <guid isPermaLink="true">http://localhost:4000/Type-on-Strap/unreal/2018/04/05/about-actor.html</guid>
        
        <category>Actor</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
  </channel>
</rss>
