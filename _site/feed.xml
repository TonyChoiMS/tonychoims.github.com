<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 24 May 2021 00:25:25 +0900</pubDate>
    <lastBuildDate>Mon, 24 May 2021 00:25:25 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>Effective C++ Today I Learn (Day1)</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;C++를 언어들의 연합체로 바라보는 안목은 필수&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;C++는 다중패러다임 프로그래밍 언어로 불립니다.
    &lt;ul&gt;
      &lt;li&gt;절차적(procedural) 프로그래밍을 기본으로 하여&lt;/li&gt;
      &lt;li&gt;객체 지향(object-oriented)&lt;/li&gt;
      &lt;li&gt;함수식(functional)&lt;/li&gt;
      &lt;li&gt;일반화(generic)&lt;/li&gt;
      &lt;li&gt;메타프로그래밍(metaprogramming)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++는 한가지 프로그래밍 규칙 아래 있는 통합 ㅇ너어가 아니라, 4개의 하위언어(sublanguage)를 제공하는 연합체로 구성되어 있습니다.
    &lt;ul&gt;
      &lt;li&gt;C : C++는 여전히 C를 기본으로 하고 있습니다.&lt;/li&gt;
      &lt;li&gt;객체 지향 개념의 C++ : 클래스(생성자와 소멸자 개념), 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩)&lt;/li&gt;
      &lt;li&gt;템플릿 C++ : C++의 일반화 프로그래밍. 템플릿 메타프로그래밍(Template MetaProgramming : TMP)&lt;/li&gt;
      &lt;li&gt;STL : 템플릿 라이브러리. 컨테이너, 반복자, 알고리즘, 함수 객체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라집니다.
    &lt;ul&gt;
      &lt;li&gt;그 경우란, 바로 C++의 어떤 부분을 사용하느냐입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;#define을 쓰려거든 const, enum, inline을 떠올리자&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가급적 선행 처리자보다 컴파일러를 더 가까이 하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;#define ASPECT_RATIO 1.653
    &lt;ul&gt;
      &lt;li&gt;define을 사용할 경우 사용자에겐 기호식 이름(symbolic name)으로 보이지만, 컴파일러는 선행 처리자가 숫자 상수로 바꾸기 때문에 ASPECT_RATIO라는 이름은 컴파일러가 쓰는 기호 테이블에 들어가지 않게 됩니다.&lt;/li&gt;
      &lt;li&gt;에러가 발생하게 될 경우 에러 메시지에 ASPECT_RATIO가 아닌 1.653이 나타나게 됩니다.&lt;/li&gt;
      &lt;li&gt;이 문제는 기호식 디버거(symbolic debugger)에서도 나타날 소지가 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 문제를 해결하기 위해 매크로 대신 상수를 쓰는 것입니다.&lt;/p&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AspectRatio&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.653&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;언어 차원에서 지원하는 상수 타입의 데이터이기 때문에 기호 테이블에 들어갑니다.&lt;/li&gt;
      &lt;li&gt;컴파일을 거친 최종 코드가 #define을 썻을 때보다 작게 나올 수 있습니다.&lt;/li&gt;
      &lt;li&gt;매크로를 쓰면 코드에 ASPECT_RATIO가 등장하면 선행 처리자가 모두 1.653으로 바꾸면서 목적 코드 안에 1.653의 사본이 등장 횟수만큼 들어가게 되지만, 상수 타입의 경우는 아무리 여러 번 쓰더라도 사본은 딱 한 개만 생기기 때문입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;#define을 상수로 교체하려고 할 때 주의해야 할 점이 있습니다.
    &lt;ul&gt;
      &lt;li&gt;상수 포인터(constant pointer)를 정의하는 경우입니다.
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;상수 정의는 대게 헤더 파일에 넣는 것이 상례이므로, 포인터는 꼭 const로 선언해 주어야 하고, 이와 더불어 포인터가 가리키는 대상까지 const로 선언하는 것이 보통입니다.&lt;/p&gt;

            &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authorName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Scott Meyers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;authorName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Scott Meyers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;클래스 멤버로 상수를 정의하는 경우, 즉 &lt;strong&gt;클래스 상수&lt;/strong&gt;를 정의하는 경우 그 상수의 사본 개수가 한 개를 넘지 못하게 하고 싶다면 정적(static) 멤버로 만들어야 합니다.
        &lt;ul&gt;
          &lt;li&gt;상수의 정의는 헤더 파일이 아닌 cpp파일어 둡니다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GamePlayer&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  			&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NumTurns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 상수 선언&lt;/span&gt;
  			&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumTurns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    
  		&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GamePlayer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumTurns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 상수 정의.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;상수의 초기값은 해당 상수가 선언된 시점에서 바로 주어지기 때문에 정의(Declaration)에는 상수의 초기값이 있으면 안됩니다. - 선언될 당시 바로 초기화.&lt;/li&gt;
          &lt;li&gt;#define은 유효범위란 무엇인지 모릅니다.
            &lt;ul&gt;
              &lt;li&gt;매크로는 정의되면 중간에 #undef되지 않는다면, 컴파일이 끝날 때까지만 유효합니다.&lt;/li&gt;
              &lt;li&gt;매크로는 어떤 형태의 캡슐화 혜택도 받을 수 없습니다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;나열자(enumerrator) 타입의 값은 int가 사용되야 할 곳에서도 쓸 수 있는 것을 적극 활용해봅니다.
    &lt;ul&gt;
      &lt;li&gt;통칭 나열자 둔갑술(enum hack)으로 알려진 기법입니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GamePlayer&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 	&lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
 		&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NumTurns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
 		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumTurns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;동작방식은 const보다는 #define에 더 가깝습니다.
        &lt;ul&gt;
          &lt;li&gt;const의 주소를 잡아내는 것은 합당하지만, enum의 주소를 취하는 것은 합당하지 않습니다.&lt;/li&gt;
          &lt;li&gt;enum은 #define과 같이 어떤 형태의 메모리 할당도 하지 않습니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;enum은 상당히 많은 코드에서 이러한 기법이 사용되고 있고, 템플릿 메타 프로그래밍의 핵심 기법이기도 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수처럼 쓰이는 매크로를 만드려면, #define보다는 인라인 함수를 우선적으로 생각합니다.&lt;/p&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;// a와 b 중에 큰 것을 f에 넘겨 호출합니다.&lt;/span&gt;
 &lt;span class=&quot;cp&quot;&gt;#define CALL_WITH_MAX(a, b) f((a) &amp;gt; (b) ? (a) : (b))
&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;CALL_WITH_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// a가 두 번 증가합니다&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;CALL_WITH_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// a가 한 번 증가합니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;이런 매크로를 사용할 경우 인자마다 반드시 괄호를 씌워줘야 합니다.&lt;/li&gt;
      &lt;li&gt;또한 잘못된 사용이 발생할 수 있기 때문에 지양하고 있습니다.&lt;/li&gt;
      &lt;li&gt;이렇기 때문에 기존 매크로의 효율을 그대로 유지하면서, 정규 함수의 모든 동작 방식 및 타입 안전성까지 완벽하게 취할 수 있는 인라인 함수에 대한 템플릿을 준비하는 것입니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;// T가 정확히 무엇인지 모르기 때문에, &lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// 매개변수로 상수 객체에 대한 참조자를 사용합니다.&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;callWithMax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 	&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;템플릿 함수는 동일 계열 함수군(Family of functions)를 만들어 냅니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;낌새만 보이면 const를 들이대보자!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;const의 의미로는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 변경을 불가능하게 하여 ‘의미적인 제약’을 소스 코드 수준에서 붙입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;어떤 값이 불변이어야 한다는 제작자의 의도를 컴파일러 및 다른 프로그래머와 나눌 수 있는 수단입니다.&lt;/p&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// 비상수 포인터, 비상수 데이터&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// 비상수 포인터, 상수 데이터&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 상수 포인터, 비상수 데이터&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 상수 포인터, 상수 데이터&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;포인터가 가리키는 대상을 상수로 할 수도 있고, 포인터 자체를 상수로 할 수 도 있습니다.&lt;/li&gt;
  &lt;li&gt;STL Iterator는 기본 동작 원리가 T* 포인터와 유사합니다.
    &lt;ul&gt;
      &lt;li&gt;단, 반복자 앞에 붙는 const는 T* const랑 의미가 동일합니다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;데이터 상수성(const T*)을 원한다면 const_iterator를 사용하면 됩니다.&lt;/p&gt;

        &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// 에러&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const_iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cIter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cIter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 에러&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cIter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함수에서 const 강력한 존재입니다.
    &lt;ul&gt;
      &lt;li&gt;함수 반환값을 상수로 선언하면 안전성이나 효율을 포기하지 않고도 의도하지 않은 버그를 예방할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rational&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//...};&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rational&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rational&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rational&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Rational&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// const 지정 때문에 대입 방지 가능.&lt;/span&gt;
                       &lt;span class=&quot;c1&quot;&gt;// operator*의 결과에 operator=를 호출&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상수 멤버 함수&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 멤버 함수가 상수 객체에서도 호출 가능한 함수라는 뜻입니다.&lt;/li&gt;
      &lt;li&gt;함수 맨 뒤에 const를 붙여서 표현합니다.&lt;/li&gt;
      &lt;li&gt;클래스의 인터페이스를 이해하기 좋게 하는 효과가 있습니다.&lt;/li&gt;
      &lt;li&gt;이 키워드를 통해 상수 객체를 사용할 수 있게 하자는 뜻입니다.&lt;/li&gt;
      &lt;li&gt;상수 객체에 대한 참조자(reference-to-const)로 진행할 때 상수 멤버 함수가 준비되어 있어야 한다는 것이 포인트입니다.&lt;/li&gt;
      &lt;li&gt;const 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능합니다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;실제 프로그램에서 상수 객체가 생기는 경우
        &lt;ol&gt;
          &lt;li&gt;상수 객체에 대한 포인터로 객체가 전달될 때&lt;/li&gt;
          &lt;li&gt;상수 객체에 대한 참조자로 객체가 전달될 때&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;물리적 상수성[비트 수준 상수성]
        &lt;ul&gt;
          &lt;li&gt;어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 ‘const’임을 인정하는 개념입니다.
            &lt;ul&gt;
              &lt;li&gt;static 멤버는 제외합니다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;즉, 멤버 포인터가 가리키는 대상의 수정 여부는 판단하지 않습니다.&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 부적절하지만 비트수준 상수성이 있어서 허용되는 선언..&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cosnt&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;논리적 상수성
        &lt;ul&gt;
          &lt;li&gt;값이 몇개 바뀌어도 사용자가 그걸 알 수 없고, 논리적으로 상수라면, 그것은 상수입니다.&lt;/li&gt;
          &lt;li&gt;mutable 키워드를 사용해 상수 객체에서도 수정 가능한 멤버를 생성할 수 있습니다.&lt;/li&gt;
          &lt;li&gt;컴파일러가 비트 수준 상수성을 지켜주지만, 개념적인(논리적인) 상수성을 사용하면서 프로그래밍 하는 사람이 되어야합니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;상수 멤버 및 비상수 멤버 함수가 기능적으로 서로 똑같이 구현되 있을 경우, 비상수 버전이 상수 버전을 호출하게 해서 코드 중복을 피하도록 합니다.
        &lt;ul&gt;
          &lt;li&gt;const_cast 를 통해 캐스팅을 하는 것은 일반적으로 썩 좋지 못한 아이디어입니다.(나중에 추가적으로 나올 얘기)&lt;/li&gt;
          &lt;li&gt;*this의 타입캐스팅을 하는 방법을 이용해 캐스팅을 한번이 아니라 두번을 하도록 합니다.
            &lt;ul&gt;
              &lt;li&gt;첫번째로 *this에 const를 붙이는 캐스팅을 하고,&lt;/li&gt;
              &lt;li&gt;두번째로 상수 반환 값에서 const를 떼어내는 캐스팅을 합니다.&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cosnt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TextBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;상수 멤버 함수에서 비상수 멤버 함수를 호출하게 되면, 데이터를 수정하지 않겠다고 약속한 객체를 배신하는 것이 되기 때문에 틀리다는 얘기가 나오는 것입니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 19 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2021/05/19/cpp-effective-til.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2021/05/19/cpp-effective-til.html</guid>
        
        <category>C++</category>
        
        <category>Effective</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>LeetCode LinkedList Cycle 문제</title>
        <description>&lt;h1 id=&quot;leetcode-linkedlist-cycle&quot;&gt;LeetCode LinkedList Cycle&lt;/h1&gt;

&lt;h2 id=&quot;leetcode-top-interview-questions의-linkedlist-탭에-있는-linkedlist-cycle-풀어보았습니다&quot;&gt;LeetCode Top Interview Questions의 LinkedList 탭에 있는 LinkedList Cycle 풀어보았습니다.&lt;/h2&gt;

&lt;h3 id=&quot;주어진-문제에서-제한된-내용은&quot;&gt;주어진 문제에서 제한된 내용은&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LinkedList의 Head가 주어졌을 때 해당 LinkedList가 Cycle을 가지는지 확인해주세요.&lt;/li&gt;
  &lt;li&gt;노드 개수는 [0, 10^4] 사이의 값을 가집니다.&lt;/li&gt;
  &lt;li&gt;노드의 값은 -10^5부터 10^5 사이의 값을 가집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주어진-문제를-풀-때-중점적으로-봐야할-점&quot;&gt;주어진 문제를 풀 때 중점적으로 봐야할 점.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;공간복잡도 O(1)으로 풀 수 있는지 확인해봅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문제에서-주어진-listnode&quot;&gt;문제에서 주어진 ListNode&lt;/h3&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;풀이방식-방식&quot;&gt;풀이방식 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;포인터를 두개 사용하여, 포인터를 이동시키는데, 이동하는 개수를 한 포인터는 한개씩만 이동합니다.&lt;/li&gt;
  &lt;li&gt;다른 한 포인터는 2개씩 이동합니다.&lt;/li&gt;
  &lt;li&gt;이후 반복문을 돌다가 두 포인터가 같은 포인터를 가리키는 경우가 발생할 경우 순회하고 있다고 판단하고 true를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasCycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/algorithm/2021/05/09/leetcode-linkedlistcycle.html</link>
        <guid isPermaLink="true">http://localhost:4000/algorithm/2021/05/09/leetcode-linkedlistcycle.html</guid>
        
        <category>C++</category>
        
        <category>Algrorithm</category>
        
        <category>LinkedList</category>
        
        <category>LinkedList Cycle</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>LeetCode PalindromeLinkedList 문제</title>
        <description>&lt;h1 id=&quot;palindromelinkedlist&quot;&gt;PalindromeLinkedList&lt;/h1&gt;

&lt;h2 id=&quot;leetcode-top-interview-questions의-linkedlist-탭에-있는-palindromelinkedlist를-풀어보았습니다&quot;&gt;LeetCode Top Interview Questions의 LinkedList 탭에 있는 PalindromeLinkedList를 풀어보았습니다.&lt;/h2&gt;

&lt;h3 id=&quot;주어진-문제에서-제한된-내용은&quot;&gt;주어진 문제에서 제한된 내용은&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;노드는 1부터 10^5까지의 개수를 가질 수 있습니다.&lt;/li&gt;
  &lt;li&gt;노드의 value는 0 &amp;lt;= value &amp;lt;= 9 까지 가질 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주어진-문제를-풀-때-중점적으로-봐야할-점&quot;&gt;주어진 문제를 풀 때 중점적으로 봐야할 점.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시간복잡도 O(n)과 공간복잡도 O(1)으로 풀 수 있는지 확인해봅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문제에서-주어진-listnode&quot;&gt;문제에서 주어진 ListNode&lt;/h3&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ListNode&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;brouteforce-방식&quot;&gt;BrouteForce 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Palindrome은 뒤집어도 똑같은지 확인하는 알고리즘 이므로, 배열의 절반을 돌면서,&lt;/li&gt;
  &lt;li&gt;앞의 값과 뒤의 값이 같은지 확인하는 방법을 사용합니다.&lt;/li&gt;
  &lt;li&gt;이 방법은 시간복잡도는 O(n)이 될 수 있으나, 공간복잡도도 O(n)이므로 문제에서 원하는 답은 아닙니다.&lt;/li&gt;
  &lt;li&gt;심지어 LeetCode에 입력해본 결과 런타임 시간도 다른 사람에 비해 엄청 높음…&lt;/li&gt;
  &lt;li&gt;Runtime: 240 ms&lt;/li&gt;
  &lt;li&gt;Memory Usage : 128.2 MB&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;val : &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;재귀호출을-이용한-방식&quot;&gt;재귀호출을 이용한 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;StackOverflow에서 소개한 방법 중 하나인데, 런타임 시간이 위에 했던 방식보다 오래걸림…&lt;/li&gt;
  &lt;li&gt;재귀호출을 이용한 방식이라 한번 적용해봤습니다.&lt;/li&gt;
  &lt;li&gt;Runtime: 268 ms&lt;/li&gt;
  &lt;li&gt;Memory Usage : 146.2 MB&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;funtional&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip_rec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ip_rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip_rec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;leetcode에서-발견한-풀이법&quot;&gt;LeetCode에서 발견한 풀이법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;포인터를 두개 사용하여, 포인터를 이동시키며 해당 값이 팰린드롬 인지 확인하는 방법입니다.&lt;/li&gt;
  &lt;li&gt;재귀호출을 이용하여 노드를 뒤집는 방법까지 사용했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
 &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest_tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;rest_tail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rest_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fast&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;slow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 20 Apr 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/algorithm/2021/04/20/leetcode-PalindromeLinkedList.html</link>
        <guid isPermaLink="true">http://localhost:4000/algorithm/2021/04/20/leetcode-PalindromeLinkedList.html</guid>
        
        <category>C++</category>
        
        <category>Algrorithm</category>
        
        <category>LinkedList</category>
        
        <category>Palindrome</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Testing MathJax</title>
        <description>&lt;p&gt;Not Pure Poole supports &lt;a href=&quot;https://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt;. You can enable it on a page by setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;math: true&lt;/code&gt; in the front matter.&lt;/p&gt;

&lt;p&gt;An inline math: \(E=mc^2\).&lt;/p&gt;

&lt;p&gt;A display math:&lt;/p&gt;

\[i\hbar \frac{\partial \Psi}{\partial t} = -\frac{\hbar^2}{2m}
\frac{\partial^2 \Psi}{\partial x^2} + V \Psi\]
</description>
        <pubDate>Fri, 02 Oct 2020 16:32:00 +0900</pubDate>
        <link>http://localhost:4000/2020/10/02/testing-mathjax.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/02/testing-mathjax.html</guid>
        
        <category>mathjax</category>
        
        
      </item>
    
      <item>
        <title>Releasing Not Pure Poole v0.1.0</title>
        <description>&lt;p&gt;The Jekyll theme &lt;strong&gt;Not Pure Poole&lt;/strong&gt; v0.1.0 was released!&lt;/p&gt;

&lt;p&gt;Not Pure Poole is a simple, beautiful, and powerful Jekyll theme for blogs. It is built on &lt;a href=&quot;https://github.com/poole/poole&quot;&gt;Poole&lt;/a&gt; and &lt;a href=&quot;https://purecss.io/&quot;&gt;Pure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For more information about this theme, you can read the &lt;a href=&quot;https://github.com/vszhub/not-pure-poole/blob/master/README.md&quot;&gt;README&lt;/a&gt; file.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Oct 2020 14:56:00 +0900</pubDate>
        <link>http://localhost:4000/2020/10/01/releasing-not-pure-poole-v0-1-0.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/01/releasing-not-pure-poole-v0-1-0.html</guid>
        
        <category>jekyll theme</category>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Not Pure Poole</title>
        <description>&lt;p class=&quot;message&quot;&gt;Welcome to &lt;strong&gt;Not Pure Poole&lt;/strong&gt;! This is an example post to show the layout.&lt;/p&gt;

&lt;p&gt;First, do you notice the TOC on the right side? Try to scroll down to read this post, you’ll find that the TOC is always sticky in the viewport.&lt;/p&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis &lt;a href=&quot;#&quot;&gt;dis parturient montes&lt;/a&gt;, nascetur ridiculus mus. &lt;em&gt;Aenean eu leo quam.&lt;/em&gt; Pellentesque ornare sem lacinia quam venenatis vestibulum. Sed posuere consectetur est at lobortis. Cras mattis consectetur purus sit amet fermentum.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Curabitur blandit tempus porttitor. Nullam quis risus eget urna mollis ornare vel eu leo. Nullam id dolor id nibh ultricies vehicula ut id elit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Etiam porta &lt;strong&gt;sem malesuada magna&lt;/strong&gt; mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.&lt;/p&gt;

&lt;h2 id=&quot;inline-html-elements&quot;&gt;Inline HTML elements&lt;/h2&gt;

&lt;p&gt;HTML defines a long list of available inline tags, a complete list of which can be found on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&quot;&gt;Mozilla Developer Network&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;To bold text&lt;/strong&gt;, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;To italicize text&lt;/em&gt;, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;mark&gt;To highlight&lt;/mark&gt;, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;mark&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Abbreviations, like &lt;abbr title=&quot;HyperText Markup Langage&quot;&gt;HTML&lt;/abbr&gt; should use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;, with an optional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;title&lt;/code&gt; attribute for the full phrase.&lt;/li&gt;
  &lt;li&gt;Citations, like &lt;cite&gt;— Mark Otto&lt;/cite&gt;, should use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Deleted&lt;/del&gt; text should use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;del&amp;gt;&lt;/code&gt; and &lt;ins&gt;inserted&lt;/ins&gt; text should use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Superscript &lt;sup&gt;text&lt;/sup&gt; uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;sup&amp;gt;&lt;/code&gt; and subscript &lt;sub&gt;text&lt;/sub&gt; uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of these elements are styled by browsers with few modifications on our part.&lt;/p&gt;

&lt;h2 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h2&gt;

&lt;p&gt;Footnotes are supported as part of the Markdown syntax. Here’s one in action. Clicking this number&lt;sup id=&quot;fnref:fn-sample_footnote&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:fn-sample_footnote&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; will lead you to a footnote. The syntax looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Clicking this number[^fn-sample_footnote]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Each footnote needs the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^fn-&lt;/code&gt; prefix and a unique ID to be referenced for the footnoted content. The syntax for that list looks something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[^fn-sample_footnote]: Handy! Now click the return link to go back.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can place the footnoted content wherever you like. Markdown parsers should properly place it at the bottom of the post.&lt;/p&gt;

&lt;h2 id=&quot;heading&quot;&gt;Heading&lt;/h2&gt;

&lt;p&gt;Vivamus sagittis lacus vel augue rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Morbi leo risus, porta ac consectetur ac, vestibulum at eros.&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;Inline code is available with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt; element. Snippets of multiple lines of code are supported through Rouge. Longer lines will automatically scroll horizontally when needed. You may also use code fencing (triple backticks) for rendering code.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Example can be run directly in your JavaScript console&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Create a function that takes two arguments and returns the sum of those arguments&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;return a + b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Call the function&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &amp;gt; 8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also optionally show code snippets with line numbers. Add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linenos&lt;/code&gt; to the Rouge tags.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// Example can be run directly in your JavaScript console&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Create a function that takes two arguments and returns the sum of those arguments&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;return a + b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Call the function&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &amp;gt; 8&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa.&lt;/p&gt;

&lt;h3 id=&quot;lists&quot;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Praesent commodo cursus magna, vel scelerisque nisl consectetur et.&lt;/li&gt;
  &lt;li&gt;Donec id elit non mi porta gravida at eget metus.&lt;/li&gt;
  &lt;li&gt;Nulla vitae elit libero, a pharetra augue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Donec ullamcorper nulla non metus auctor fringilla. Nulla vitae elit libero, a pharetra augue.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Vestibulum id ligula porta felis euismod semper.&lt;/li&gt;
  &lt;li&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.&lt;/li&gt;
  &lt;li&gt;Maecenas sed diam eget risus varius blandit sit amet non magna.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cras mattis consectetur purus sit amet fermentum. Sed posuere consectetur est at lobortis.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;HyperText Markup Language (HTML)&lt;/dt&gt;
  &lt;dd&gt;The language used to describe and define the content of a Web page&lt;/dd&gt;

  &lt;dt&gt;Cascading Style Sheets (CSS)&lt;/dt&gt;
  &lt;dd&gt;Used to describe the appearance of Web content&lt;/dd&gt;

  &lt;dt&gt;JavaScript (JS)&lt;/dt&gt;
  &lt;dd&gt;The programming language used to build advanced Web sites and applications&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;h3 id=&quot;images&quot;&gt;Images&lt;/h3&gt;

&lt;p&gt;Quisque consequat sapien eget quam rhoncus, sit amet laoreet diam tempus. Aliquam aliquam metus erat, a pulvinar turpis suscipit at.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://placehold.it/800x400&quot; alt=&quot;placeholder&quot; title=&quot;Large example image&quot; /&gt;
&lt;img src=&quot;http://placehold.it/400x200&quot; alt=&quot;placeholder&quot; title=&quot;Medium example image&quot; /&gt;
&lt;img src=&quot;http://placehold.it/200x200&quot; alt=&quot;placeholder&quot; title=&quot;Small example image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Align to the center by adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class=&quot;align-center&quot;&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://placehold.it/400x200&quot; alt=&quot;placeholder&quot; title=&quot;Medium example image&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tables&quot;&gt;Tables&lt;/h3&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Upvotes&lt;/th&gt;
      &lt;th&gt;Downvotes&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;Totals&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alice&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bob&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Charlie&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Nullam id dolor id nibh ultricies vehicula ut id elit. Sed posuere consectetur est at lobortis. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/vszhub/not-pure-poole/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:fn-sample_footnote&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Handy! Now click the return link to go back. &lt;a href=&quot;#fnref:fn-sample_footnote&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 30 Sep 2020 00:18:00 +0900</pubDate>
        <link>http://localhost:4000/2020/09/30/welcome-to-not-pure-poole.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/30/welcome-to-not-pure-poole.html</guid>
        
        <category>jekyll theme</category>
        
        <category>jekyll</category>
        
        <category>tutorial</category>
        
        
      </item>
    
      <item>
        <title>C++ 용어에 대한 정리</title>
        <description>&lt;p&gt;[최종수정 2021-04-30]&lt;/p&gt;

&lt;h1 id=&quot;c-용어정리-&quot;&gt;&lt;strong&gt;C++ 용어정리 !!&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;C++ 스타일의 캐스팅&lt;/p&gt;

&lt;h2 id=&quot;namespace&quot;&gt;namespace&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코드 안에서 같은 이름으로 변수와 함수 이름을 지어야 할 상황이 발생할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;그리고 외부에서 참조하는 소스를 사용하다 보면 같은 이름의 변수나 함수가 있어서 난감한 상황이 생길 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이러한 문제를 해결하기 위해 고안된 것이 네임스페이스 입니다.&lt;/li&gt;
  &lt;li&gt;네임스페이스는 변수나 함수를 해당 영역에서만 유효하도록 제한하는 것입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;static_cast&quot;&gt;static_cast&amp;lt;&amp;gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가장 기본적인 캐스트 연산 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dynamic_cast&quot;&gt;dynamic_cast&amp;lt;&amp;gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;객체지향 언어의 다형성을 이용하여 모호한 타입 캐스팅 오류를 막아주는 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;const_cast&quot;&gt;const_cast&amp;lt;&amp;gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자료형이 갖고 있는 상수 속성을 제거하는 캐스팅&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&amp;lt;&amp;gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떠한 포인터 타입끼리도 변환할 수 있게 도움을 주는 캐스팅&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;포인터&quot;&gt;포인터&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;변수의 주소를 가리키는 것.&lt;/li&gt;
  &lt;li&gt;*(Asterisk)가 붙은 변수는 실제 값이 아니라 주소를 저장한다는 의미입니다.&lt;/li&gt;
  &lt;li&gt;그렇기 때문에 포인터 변수를 출력하게 되면 실제 값이 아닌 메모리주소값을 확인 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;이 주소값은 사용자가 임의로 주소를 지정할 순 있지만, 대체로 컴퓨터 내부적으로 할당하고 그 값을 이용하고 있습니다.&lt;/li&gt;
  &lt;li&gt;&amp;amp;(Ampersand)는 변수의 주소를 불러오는 의미입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;또는 &amp;amp;이 붙어있는 변수의 크기를 출력하게 되면 변수가 가지고 있는 자료형의 크기가 아닌, 포인터의 크기를 출력하게 됩니다.(4Byte)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포인터를 사용하면 프로그램 전체 성능을 올리는데 도움이 되기도 합니다.&lt;/li&gt;
  &lt;li&gt;함수는 인자로 넘어오는 값을 복사하여 사용하는데, 만약 인자가 크다면 복사하는데 많은 시간이 소요됩니다.&lt;/li&gt;
  &lt;li&gt;이 때 인자로 포인터를 넘겨줄 경우 4byte(64비트의 경우 8byte) 주소만 넘겨주도록 할 수 있기 때문에 훨씬 효율적입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## 포인터 배열&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;배열을 하나 선언하고 포인터 변수에 그 주소를 지정할 경우, 해당 변수는 배열의 제일 첫 인덱스 주소를 가리키고 있게 됩니다.&lt;/li&gt;
  &lt;li&gt;이 때 변수에 증감 연산자를 통해 주소를 증가시키면 포인터가 배열의 뒤쪽의 인덱스를 가리키게 변경됩니다.&lt;/li&gt;
  &lt;li&gt;배열은 선언과 함께 초기화 하는 습관이 중요합니다.&lt;/li&gt;
  &lt;li&gt;만약 배열을 초기화하지 않으면 쓰레기 값이 들어가 나중에 버그 등이 발생할 떄 원인이 되기도 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;변수의-유효범위&quot;&gt;변수의 유효범위&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;변수는 값이 저장되는 메모리 영역이나 변수의 유효범위에 따라 구분되는데, auto, static, extern 이 세가지 키워드를 이용하여 구분을 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;변수의 유효범위는 크게 지역변수(local variable)와 전역변수(global vriable)로 나뉘며, 실제 프로그램 실행시에 변수가 저장되는 메모리상의 위치에 따라
높은 주소값부터 사용하는 stack, 낮은 주소값부터 사용하는 정적 데이터 영역(.data, .bss)과 힙(heap)으로 구분됩니다.&lt;/li&gt;
  &lt;li&gt;최적화 관점에서 살펴보면, 스택의 경우 해당 Scope에서 자주 액세스 되며 범위가 끝나면 없어지는 임시 변수들이 저장되는데, 스택포인터를 순차적으로
이동해가며 할당되기 때문에 할당 속도가 빠르며, 해당 변수들이 자주사용되서 CPU 캐시의 히트율이 높은 경우 접근 속도도 더 빨라진다. 하지만 Scope가 끝나면
없어지기 때문에 계속적으로 값을 유지하는 것이 불가능하다.&lt;/li&gt;
  &lt;li&gt;정적인 변수들은 정적 데이터 영역에 저장하여 계속 유지되며, 동적인 변수들은 힙에 변수를 할당하고 저장한다.&lt;/li&gt;
  &lt;li&gt;힙은 비순차적 메모리 할당/해제가 계속 일어나는 동적인 특성을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;그렇기 때문에 스택처럼 메모리 할당을 순차적으로 하기가 힘들어서 정적인 방식에 비해 할당 속도가 느린 특성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정적-변수static&quot;&gt;정적 변수(static)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;블럭 안에서만 유효한 값을 가지지만 자동변수와 같이 없어지지 않고 블럭으로 다시 돌아왔을 때 이전 값을 다시 이용 가능한 변수입니다.&lt;/li&gt;
  &lt;li&gt;스택이 아닌 정적데이터 영역에 저장되는 변수입니다.&lt;/li&gt;
  &lt;li&gt;초기화를 생략하면 0으로 자동 초기화됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전역-변수-extern&quot;&gt;전역 변수 (extern)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;함수 밖의 전역 범위에 선언되며, 프로그램 전체에서 유효하고 다른 파일에서 참조 가능한 변수입니다.&lt;/li&gt;
  &lt;li&gt;초기화를 생략하면 0으로 자동 초기화가 진행됩니다.&lt;/li&gt;
  &lt;li&gt;정적 데이터영역에 할당됩니다.&lt;/li&gt;
  &lt;li&gt;extern 변수는 편리하지만, 남발하면 프로그램을 복잡하게 하고 나중에 유지보수가 힘들기 때문에 사용을 최소화 하는 것이 바람직합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;call-by-value&quot;&gt;Call by Value&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;함수의 인자로 넘어온 값을 내부적으로 복사해서 사용합니다.&lt;/li&gt;
  &lt;li&gt;그러므로 인자로 넘어온 값을 변경한다 하더라도, 인자로 넘긴 변수를 변경한 것이 아닌, 복사된 값만 변경한 것이기 때문에 함수 종료 후 해당 값을 다시 확인해보면 변경되지 않은 것을 확인할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;call-by-reference&quot;&gt;Call by Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;함수의 인자로 &amp;amp;(Ampersand)를 받게 될 경우, 인자의 값을 복사하는 것이 아닌 인자의 주소값(포인터)를 사용하기 떄문에
값이 아닌 주소값을 가리키는 것이므로 함수 내부에서 인자의 값을 변경하게 될 경우, 함수 종료 이후에 값을 확인해보면 변경된 값을 확인 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;call-by-address&quot;&gt;Call by Address&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;함수의 인자로 *(Asterisk)를 받게 될 경우, 함수 호출하는 곳에서는 주소를 명시적으로 전달해야 합니다.&lt;/li&gt;
  &lt;li&gt;함수는 인자로 주소를 받는데, 이 경우 함수 호출하는 곳에서는 값을 그대로 넘기지만 받는 측에서는 포인터로 받습니다.&lt;/li&gt;
  &lt;li&gt;함수에 인자를 전달 할 때 변수의 주소를 명시적으로 알려주면 포인터의 크기로 인자가 넘어가지만,
함수를 호출할 때 변수를 넣고 넘어오는 값을 포인터로 받으면 자료형만큼의 바이트만 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;선언-declaration&quot;&gt;선언 (Declaration)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코드에 사용되는 ‘어떤 대상’의 이름과 타입을 컴파일러에게 알려주는 것. 구체적인 세부사항은 선언에 들어있지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시그니처-signature&quot;&gt;시그니처 (Signature)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 함수 선언문에 매개변수 리스트와 반환 타입이 나와있는 것을 말합니다.&lt;/li&gt;
  &lt;li&gt;함수의 경우 시그니처가 그 함수의 타입입니다.&lt;/li&gt;
  &lt;li&gt;공식적인 C++ 정의에서는 함수의 반환 타입을 시그니처에서 제외하고 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정의-definition&quot;&gt;정의 (Definition)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;선언에서 빠진 구체적인 세부사항을 컴파일러에게 제공하는 것입니다.&lt;/li&gt;
  &lt;li&gt;객체의 경우에 있어서 정의는 컴파일러가 그 객체에 대한 메모리를 마련해 놓는 부분이 됩니다.&lt;/li&gt;
  &lt;li&gt;클래스 혹은 클래스 템플릿의 경우에는 그 클래스 혹은 템플릿의 멤버를 넣어 준 결과가 정의입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;초기화-initialization&quot;&gt;초기화 (Initialization)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 객체에 최초의 값을 부여하는 과정입니다.&lt;/li&gt;
  &lt;li&gt;사용자 정의 타입으로 생성한 객체의 경우, 초기화는 생성자에 의해 이루어집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기본-생성자deafult-constructor&quot;&gt;기본 생성자(Deafult Constructor)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 인자도 주어지지 않은 채로 호출될 수 있는 생성자입니다. 원래부터 매개변수가 없거나 모든 매개변수가 기본 값을 갖고 있으면 기본 생성자가 될 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;복사-생성자-copy-constructor&quot;&gt;복사 생성자 (Copy Constructor)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 객체의 초기화를 위해 그와 같은 타입의 객체로부터 초기화할 때 호출되는 함수입니다. (ex. Pass by Value)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;복사-대입-연산자-copy-assignment-operator&quot;&gt;복사 대입 연산자 (Copy Assignment Operator)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;정의되지 않은 동작.&lt;/li&gt;
  &lt;li&gt;실행 시간에 어떤 현상이 터질지 확실히 예측할 수 없다는 뜻입니다.&lt;/li&gt;
  &lt;li&gt;널 포인터를 역참조하면 미정의 동작이 발생합니다.&lt;/li&gt;
  &lt;li&gt;유효하지 않은 배열 원소 지정번호(Index)로 참조하려 하면 미정의 동작이 발생합니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/c++/programming/2020/05/24/about-cpp-basic.html</link>
        <guid isPermaLink="true">http://localhost:4000/c++/programming/2020/05/24/about-cpp-basic.html</guid>
        
        <category>C++</category>
        
        <category>programming</category>
        
        
        <category>C++</category>
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>Unreal Engine 데미지 프레임워크</title>
        <description>&lt;h1 id=&quot;데미지-프레임워크&quot;&gt;데미지 프레임워크&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 05 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2020/05/05/about-damage-framework.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2020/05/05/about-damage-framework.html</guid>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine AI Perception</title>
        <description>&lt;p&gt;In addition to Behavior Trees which can be used to make decisions on which logic to execute, and the Environmental Query System (EQS) used to retrieve information about the environment; another tool you can use within the AI framework which provides sensory data for an AI is the AI Perception System. This provides a way for Pawns to receive data from the environment, such as where noises are coming from, if the AI was damaged by something, or if the AI sees something. This is accomplished with the AI Perception Component that acts as a stimuli listener and gathers registered Stimuli Sources.&lt;/p&gt;

&lt;p&gt;AI가 실행할 로직에 대한 결정을 내리는 데 사용할 수 있는 비헤이비어 트리와 환경에 대한 정보를 검색하는 데 사용되는 환경 쿼리 시스템 (EQS) 외에 AI 프레임 워크 내에서 사용할 수 있는 AI에 대한 감각 데이터를 제공하는 또 다른 도구는 AI Perception System입니다. 이것은 폰이 노이즈가 발생하는 곳, AI가 무언가에 의해 손상된 경우 또는 AI가 무언가를 보는 것과 같은 것으로부터 데이터를 수신하는 방법을 제공합니다. 이것은 자극 청취자 역할을하고 등록 된 자극 소스를 수집하는 AI Perception Component로 구성됩니다.&lt;/p&gt;

&lt;p&gt;When a stimuli source is registered, the event On Perception Updated (or On Target Perception Updated for target selection) is called which you can use to fire off new Blueprint Script and (or) update variables that are used to validate branches in a Behavior Tree.&lt;/p&gt;

&lt;p&gt;Stimuli Source가 등록되면, 새로운 블루 프린트 스크립트를 시작하고 행동 트리에서 브랜치를 검증하는 데 사용되는 변수를 업데이트하는 데 사용할 수있는 On Perception Updated (또는 대상 선택에 대한 On Target Perception Updated) 이벤트가 호출됩니다.&lt;/p&gt;

&lt;h2 id=&quot;ai-perception-component&quot;&gt;AI Perception Component&lt;/h2&gt;

&lt;p&gt;The AI Perception Component is a type of Component thatcan be added to a Pawn’s Blueprint from the Components window and is used to define what senses to listen for, the parameters for those senses, and how to respond when a sense has been detected. You can also use several different functions to get information about what was sensed, what Actors were sensed, or even disable or enable a particular type of sense.&lt;/p&gt;

&lt;p&gt;AI Perception Component는 Components 창에서 Pawn의 Blueprint에 추가 할 수있는 Component 유형으로, 데이터 수집을 원하는 감각과 해당 감각에 대한 매개 변수 및 감각이 감지 될 때 반응하는 방법을 정의하는 데 사용됩니다. 또한 여러 다른 기능을 사용하여 감지 된 것, 감지 된 행위자에 대한 정보를 얻거나 특정 유형의 감지를 비활성화 또는 활성화 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;In addition to the common properties available with in the Details panel for the AI Perception Component, you can add the type of Senses to perceive under the AI Perception and Senses Config section. Depending on the type of Sense, different properties are available to adjust how the Sense is perceived.&lt;/p&gt;

&lt;p&gt;AI Perception 구성 요소에 대한 세부 정보 패널에서 사용할 수있는 공통 속성 외에도 AI Perception and Senses Config 섹션에서 감지 할 감지 유형을 추가 할 수 있습니다. 감지 유형에 따라 감지 속성을 조정하기 위해 다양한 속성을 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;note&quot;&gt;Note&lt;/h3&gt;
&lt;p&gt;The Dominant Sense property can be used to assign a Sense that should take precedence over other senses when determining a sensed Actor’s location. This should be set to one of the senses configured in your Senses Config section or set to None.&lt;/p&gt;

&lt;p&gt;Dominant Sense 프로퍼티는 감지 된 액터의 위치를 ​​결정할 때 다른 감각보다 우선해야하는 감각을 할당하는 데 사용될 수 있습니다. 이것은 Senses Config 섹션에서 구성된 감각 중 하나로 설정되거나 None으로 설정되어야합니다.&lt;/p&gt;

&lt;h3 id=&quot;ai-damage&quot;&gt;AI Damage&lt;/h3&gt;
&lt;p&gt;If you want your AI to react to damage events such as Event Any Damage , Event Point Damage , or Event Radial Damage , you can use the AI Damage Sense Config. The Implementation property (which defaults to the engine class AISense_Damage) can be used to determine how damage events are handled, however you can create your own damage classes through C++ code.&lt;/p&gt;

&lt;p&gt;AI가 Event Any Damage, Event Point Damage 또는 Event Radial Damage와 같은 손상 이벤트에 반응하게하려면 AI Damage Sense Config를 사용할 수 있습니다. 구현 속성 (기본값은 엔진 클래스 AISense_Damage)을 사용하여 손상 이벤트 처리 방법을 결정할 수 있지만 C ++ 코드를 통해 고유 한 손상 클래스를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;Implementation  이 항목에 사용할 AI 감지 클래스
Debug Color     When using the AI Debugging tools, what color to draw the debug lines.
Max Age         Determines the duration in which the stimuli generated by this sense becomes forgotten (0 means never forgotten).
Starts Enabled  Determines whether the given sense starts in an enabled state or must be manually enabled/disabled.
  &amp;lt;/br&amp;gt;
&amp;lt;/br&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;ai-hearing&quot;&gt;AI Hearing&lt;/h3&gt;
&lt;p&gt;The AI Hearing sense can be use to detect sounds generated by a Report Noise Event, for example, a projectile hits something and generates a sound which can be registered with the AI Hearing sense.
  &amp;lt;/br&amp;gt;
AI Hearing 센스는 Report Noise Event에 의해 생성 된 사운드를 감지하는 데 사용할 수 있습니다. 예를 들어, 발사체가 무언가를 치고 AI Hearing 센스에 등록 할 수있는 사운드를 생성합니다.
&amp;lt;/br&amp;gt;
&amp;lt;/br&amp;gt;
Implementation              The AI Sense Class to use for this entry (defaults to AISense_Hearing).
Hearing Range               The distance in which this sense can be perceived by the AI Perception system.
Lo SHearing Range           This is used to display a different radius in the debugger for Hearing Range.
Detection by Affiliation    Determines if Enemies, Neutrals, or Friendlies can trigger this sense.
Debug Color                 When using the AI Debugging tools, what color to draw the debug lines.
Max Age                     Determines the duration in which the stimuli generated by this sense becomes forgotten (0 means never forgotten).
Starts Enabled              Determines whether the given sense starts in an enabled state or must be manually enabled/disabled.
&amp;lt;/br&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;ai-prediction&quot;&gt;AI Prediction&lt;/h3&gt;
&lt;p&gt;&amp;lt;/br&amp;gt;
This asks the Perception System to supply Requestor with PredictedActor’s predicted location in PredictionTime seconds.&lt;/p&gt;

&lt;p&gt;이를 통해 Perception 시스템은 PredictionTime 초 내에 PredictedActor의 예상 위치를 요청자에게 제공하도록 요청합니다.&lt;/p&gt;

&lt;p&gt;Debug Color                 When using the AI Debugging tools, what color to draw the debug lines.
Max Age                     Determines the duration in which the stimuli generated by this sense becomes forgotten (0 means never forgotten).
Starts Enabled              Determines whether the given sense starts in an enabled state or must be manually enabled/disabled.&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;ai-sight&quot;&gt;AI Sight&lt;/h3&gt;
&lt;p&gt;&amp;lt;/br&amp;gt;
The AI Sight config enables you to define parameters that allow an AI character to “see” things in your Level. When an Actor enters the Sight Radius, the AI Perception System signals an update and passes through the Actor that was seen (for example a Player enters the radius and is perceived by the AI who has Sight Perception).&lt;/p&gt;

&lt;p&gt;AI Sight 구성을 사용하면 AI 캐릭터가 레벨에서 사물을 “볼”수있는 매개 변수를 정의 할 수 있습니다. 액터가 시력 반경에 들어가면 AI Perception System은 업데이트 신호를 보내고 본 액터를 통과합니다 (예 : 플레이어가 반경에 들어가서 시력을 인식하는 AI에 의해 인식됨).&lt;/p&gt;

&lt;p&gt;Implementation                          The AI Sense Class to use for this entry (defaults to AISense_Sight).&lt;/p&gt;

&lt;p&gt;Sight Radius                            The max distance over which this sense can start perceiving.&lt;/p&gt;

&lt;p&gt;Lose Sight Radius                       The max distance in which a seen target is no longer perceived by the sight sense.&lt;/p&gt;

&lt;p&gt;Peripheral Vision Half Angle Degrees    How far to the side the AI can see in degrees. The value represents the angle measured in relation to the forward vector, not the whole range. You can use SetPeripheralVisionAngle in Blueprint to change the value at runtime.&lt;/p&gt;

&lt;p&gt;Detection by Affiliation                Determines if Enemies, Neutrals, or Friendlies can trigger this sense. This property can be used to set up Sight perception for teams. Currently, Affiliation can only be defined in C++. For Blueprints, you can use the Detect Neutrals option to detect all Actors, then use Tags to filter out Actor types.&lt;/p&gt;

&lt;p&gt;Auto Success Range from Last Seen Location  When greater than zero, the AI will always be able to see the a target that has already been seen as long as they are within the range specified here.&lt;/p&gt;

&lt;p&gt;Debug Color                             When using the AI Debugging tools, what color to draw the debug lines.&lt;/p&gt;

&lt;p&gt;Max Age                                 Determines the duration in which the stimuli generated by this sense becomes 
forgotten (0 means never forgotten).&lt;/p&gt;

&lt;p&gt;Starts Enabled                          Determines whether the given sense starts in an enabled state or must be manually enabled/disabled.&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;ai-team&quot;&gt;AI Team&lt;/h3&gt;
&lt;p&gt;&amp;lt;/br&amp;gt;
This notifies the Perception component owner that someone on the same team is close by (radius is sent by the gameplay code which sends the event).&lt;/p&gt;

&lt;p&gt;이것은 같은 팀의 누군가가 가까이에 있음을 Perception 컴포넌트 소유자에게 알립니다 (반경은 이벤트를 보내는 게임 플레이 코드에 의해 보내집니다).&lt;/p&gt;

&lt;p&gt;Debug Color                 When using the AI Debugging tools, what color to draw the debug lines.&lt;/p&gt;

&lt;p&gt;Max Age                     Determines the duration in which the stimuli generated by this sense becomes forgotten (0 means never forgotten).&lt;/p&gt;

&lt;p&gt;Starts Enabled              Determines whether the given sense starts in an enabled state or must be manually enabled/disabled.&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;ai-touch&quot;&gt;AI Touch&lt;/h3&gt;
&lt;p&gt;&amp;lt;/br&amp;gt;
The AI Touch config setting gives you the ability to detect when the AI bumps into something or something bumps into it. For example, in a stealth based game, you may want a Player to sneak by an enemy AI without touching them. Using this Sense you can determine when the Player touches the AI and can respond with different logic.&lt;/p&gt;

&lt;p&gt;AI Touch 구성 설정을 사용하면 AI가 무언가 또는 무언가에 부딪 치는시기를 감지 할 수 있습니다. 예를 들어, 스텔스 기반 게임에서 플레이어가 적 AI에 닿지 않고 몰래 들어가기를 원할 수 있습니다. 이 Sense를 사용하면 플레이어가 AI를 터치하는 시점을 결정하고 다른 논리로 응답 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Debug Color             When using the AI Debugging tools, what color to draw the debug lines.&lt;/p&gt;

&lt;p&gt;Max Age                 Determines the duration in which the stimuli generated by this sense becomes forgotten (0 means never forgotten).&lt;/p&gt;

&lt;p&gt;Starts Enabled          Determines whether the given sense starts in an enabled state or must be manually enabled/disabled.&lt;/p&gt;

&lt;h3 id=&quot;perception-events&quot;&gt;Perception Events&lt;/h3&gt;
&lt;p&gt;The Events section enables you to define what happens when the AI Perception System receives an update or when the AI Perception Component is activated or deactivated.&lt;/p&gt;

&lt;p&gt;Events 섹션에서는 AI Perception System이 업데이트를 받거나 AI Perception 구성 요소가 활성화 또는 비활성화 될 때 발생하는 상황을 정의 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;On Perception Updated           이 이벤트는 Perception System이 업데이트를 수신하면 시작되고 업데이트를 알리는 액터 배열을 반환합니다.&lt;/p&gt;

&lt;p&gt;On Target Perception Updated    이 이벤트는 Perception System이 업데이트를 받으면 시작되고 업데이트를 알리는 액터를 반환합니다. 또한 추가 정보를 검색하기 위해 분류 할 수있는 AI Stimulus 구조체를 반환합니다.&lt;/p&gt;

&lt;p&gt;On Component Activated          An Event that is fired when the AI Perception Component is activated.&lt;/p&gt;

&lt;p&gt;On Component Deactivated        An Event that is fired when the AI Perception Component is deactivated.&lt;/p&gt;

&lt;p&gt;Perception Function Calls
The following functions can be called through Blueprint to get information from or affect the Perception System.
블루 프린트를 통해 다음 함수를 호출하여 Perception System에서 정보를 얻거나 영향을 줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;Get Actors Perception                Retrieves whatever has been sensed about a given Actor and returns a Sensed Actor’s Data structure.&lt;/p&gt;

&lt;p&gt;Get Currently Perceived Actors       Returns all Actors that are being perceived based on a given Sense. If no Sense is specified, all Actors currently perceived in any way will be returned.&lt;/p&gt;

&lt;p&gt;Get Known Perceived Actors           Returns any Actors that have been perceived (and not yet forgotten) based on a given Sense. If no Sense is specified, all Actors that have been perceived will be returned.&lt;/p&gt;

&lt;p&gt;Get Perceived Hostile Actors         Returns the list of Hostile Actors (any hostile Actors that had a stimulus sensed which is not expired or successfully sensed). Method can be overridden in Blueprint to return whatever Actors list the user wants.&lt;/p&gt;

&lt;p&gt;Request Stimuli Listener Update      Manually forces the AI Perception System to update properties for the specified target stimuli listener.&lt;/p&gt;

&lt;p&gt;Set Sense Enabled                    Enable or Disable the specified Sense Class.  This only works if the given Sense has already been configured for the target component instance.&lt;/p&gt;

&lt;h3 id=&quot;stimuli-source&quot;&gt;Stimuli Source&lt;/h3&gt;

&lt;p&gt;The AI Perception Stimuli Source Component gives the owning Actor a way to automatically register itself as a stimuli source for the designated Sense(s) within the Perception System. An example use case would be to have an AI character with an AI Perception Component set up to perceive stimuli based on Sight. You could then use the Stimuli Source Component in an Actor (such as an item pickup Actor) and register it as a stimuli for Sight (which would enable the AI to “see” the Actor in the Level).&lt;/p&gt;

&lt;p&gt;AI Perception Stimuli Source Component는 소유 액터에게 Perception System 내의 지정된 Sense에 대한 자극 소스로 자동 등록하는 방법을 제공합니다. 사용 사례의 예로는 AI Perception Component가있는 AI 캐릭터가 Sight를 기반으로 자극을 인식하도록 설정하는 것입니다. 그런 다음 액터 (예 : 아이템 픽업 액터)에서 Stimuli Source Component를 사용하여 Sight의 자극으로 등록 할 수 있습니다 (AI가 레벨에서 액터를 “볼”수 있도록합니다).&lt;/p&gt;

&lt;p&gt;Property&lt;/p&gt;

&lt;p&gt;Auto Register as Source
Whether to automatically register the stimuli for the specified sense with respect to the owning Actor.&lt;/p&gt;

&lt;p&gt;소유 액터에 대해 지정된 감각에 대한 자극을 자동으로 등록할지 여부.&lt;/p&gt;

&lt;p&gt;Register as Source for Senses
An array of Senses to register as a source for. Click the + sign to add a Source, then click the drop-down and assign the desired Sense.
소스로 등록 할 감각 배열입니다. + 부호를 클릭하여 소스를 추가 한 다음 드롭 다운을 클릭하고 원하는 감지를 지정하십시오.&lt;/p&gt;

&lt;p&gt;You can also assign any custom Senses that have been based on the AISense Class.
AISense 클래스를 기반으로 한 사용자 지정 감지를 할당 할 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;stimuli-function-calls&quot;&gt;Stimuli Function Calls&lt;/h3&gt;
&lt;p&gt;The following functions can be called through Blueprint for the AI Perception Stimuli Source Component:
AI Perception Stimuli Source Component에 대한 블루 프린트를 통해 다음 함수를 호출 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Register for Sense          Registers owning Actor as a stimuli source for the specified Sense class.&lt;/p&gt;

&lt;p&gt;Register with Perception System :
Registers owning Actor as a stimuli source for Senses specified in the Register as Source for Senses property and through the Register for Sense function call.&lt;/p&gt;

&lt;p&gt;You do not need to call this function if the Auto Register as Source property is enabled.&lt;/p&gt;

&lt;p&gt;Unregister from Perception System :
Unregisters the owning Actor from being a source of Sense stimuli.&lt;/p&gt;

&lt;p&gt;Unregister from Sense :
Unregisters the stimuli for the specified sense with respect to the owning Actor.&lt;/p&gt;

&lt;h3 id=&quot;ai-perception-debugging&quot;&gt;AI Perception Debugging&lt;/h3&gt;
&lt;p&gt;You can debug AI Perception using the AI Debugging tools by pressing the ‘(apostrophe) key while your game is running, then pressing numpad key 4 to bring up the Perception information.&lt;/p&gt;

&lt;p&gt;게임이 실행되는 동안 ‘(아포스트로피) 키를 누른 다음 숫자 키 4를 눌러 인식 정보를 표시하면 AI 디버깅 도구를 사용하여 AI 인식을 디버깅 할 수 있습니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 05 May 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2020/05/05/about-ai-perception.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2020/05/05/about-ai-perception.html</guid>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine 입문 시작</title>
        <description>&lt;p&gt;입문과 팁&lt;/p&gt;

&lt;p&gt;UObject : 기본이 되는 클래스 =&amp;gt; 유니티의 Component
 -&amp;gt; 가비지 컬렉터, 레퍼런스 업데이트
 -&amp;gt; 레퍼런스 카운터 존재
 -&amp;gt; 스마트포인터 사용 권장.&lt;/p&gt;

&lt;p&gt;AActor : 게임 내에 배치되는 오브젝트. (= GameObject), UObject 상속
 -&amp;gt; 하지만 가비지 컬렉션에 의해 관리되지 않고, 해제자를 통해서만 해제를 할 수 있다.
 -&amp;gt; 레퍼런스 카운터가 없음.&lt;/p&gt;

&lt;p&gt;object와 actor의 차이점.
 -&amp;gt; UObject를 상속하는 클래스 받는 클래스 접두사는 U
 -&amp;gt; AActor를 상속하는 클래스 받는 클래스 접두사는 A&lt;/p&gt;

&lt;p&gt;클래스를 생성할 때 이름에 A 또는 U는 자동으로 붙여지기 떄문에 따로 입력하지 않는다.&lt;/p&gt;

&lt;p&gt;APawn, ACharacter : 게임 상에서 움직이는 모든 액터들을 표현할 떄 사용하는 클래스.&lt;/p&gt;

&lt;p&gt;APawn과 ACharacter의 차이 : ACharacter는 2족보행(인간형)에 특화된 APawn&lt;/p&gt;

&lt;p&gt;UActorComponent : 기능만 구현. Actor에 귀속되는 컴포넌트&lt;/p&gt;

&lt;p&gt;USceneComponent : Transform을 가지고 있는 컴포넌트. ex 카메라.&lt;/p&gt;

&lt;p&gt;CDO Class Default Object&lt;/p&gt;

&lt;p&gt;클래스 생성자로 인해 생성된 이후로 변경되지 않음.&lt;/p&gt;

&lt;p&gt;C++ 구조.&lt;/p&gt;

&lt;p&gt;include generated.h : 리플렉션이라는 실행 시간에 자신을조사할 수 있는 기능이 동작.
PROJECTDRU_API
리플렉션이란? 런타임에 객체의 정보를 알 수 있는기능.
 -&amp;gt; 실행 중에 (런타임중) 클래스가 무엇을 가지고 있는지, 어떤 기능을 수행하는지 알 수 있는 기능.
 -&amp;gt; 실행 중에 프로퍼티를 제공할 수 있는 기능.
 -&amp;gt; generated.h가 존재하는 이유.
 -&amp;gt; C++에는 리플렉션이 없다. 유일하게 언리얼만이 리플렉션 기능을 갖추고 있다.&lt;/p&gt;

&lt;p&gt;GENREATED_BODY() 매크로.
 -&amp;gt; 이 매크로 아래 작성되는 변수 및 함수는 public이 default로 선언된다.
 -&amp;gt; 가독성을 위해 public, private는 명시적으로 선언해주는 것이 좋다.&lt;/p&gt;

&lt;p&gt;언리얼 엔진 클래스는 DLL로 관리.&lt;/p&gt;

&lt;p&gt;언리얼 모듈에 대한 이해 필요.&lt;/p&gt;

&lt;p&gt;핫리로드 : 생성자 수정 또는 헤더에서 수정할 경우 적용이 잘 안되는 경우 존재.&lt;/p&gt;

&lt;p&gt;언리얼변수 UPROPERTY 매크로 사용. 블루프린트에서 변수를 사용할 경우는 UPROPERTY가 public 변수여야함.&lt;/p&gt;

&lt;p&gt;언리얼의 코딩 표준에서는 변수는 대문자로 시작한다.&lt;/p&gt;

&lt;p&gt;AController는 AActor를 상속받는 클래스.&lt;/p&gt;

&lt;p&gt;FConstPlayerControllerIterator&lt;/p&gt;

&lt;p&gt;TActorIterator&lt;/p&gt;

&lt;p&gt;Check 기능.&lt;/p&gt;

&lt;p&gt;UE_LOG&lt;/p&gt;

&lt;p&gt;EngineUtils.h -&amp;gt; GEngine-&amp;gt;AddOnScreenDebugMessage&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Print함수와 동일.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;언리얼이 유니티보다 먼저 나옴&lt;/p&gt;

&lt;p&gt;#include “Engine/World.h”&lt;/p&gt;

&lt;p&gt;unit의 기본단위 unity : m // unreal : cm.&lt;/p&gt;

&lt;p&gt;GetPlayerPawn -&amp;gt; GetPlayerCharacter를 더 많이씀.
 -&amp;gt; 차이점.&lt;/p&gt;

&lt;p&gt;Kismet -&amp;gt; 언리얼3에서 쓰이는 비주얼스크립팅.
 언리얼4에서의 블루프린트 스크립팅.&lt;/p&gt;

&lt;p&gt;블루프린트에서 제공하는 함수들을 사용하고 싶을때는 Kismet을 include로 가져와야 한다.&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Jan 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2019/01/19/about-unrealengine.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2019/01/19/about-unrealengine.html</guid>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Direct3D Vector</title>
        <description>&lt;h3 id=&quot;벡터vector-방향량&quot;&gt;벡터(Vector, 방향량)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;크기(Magnitude)와 방향(Direction)을 모두 가진 수량(Quantity)을 가리키는 말&lt;/li&gt;
  &lt;li&gt;좀 더 정확하게는 벡터값 수량(Vector-valued quantity)이라고 부른다.&lt;/li&gt;
  &lt;li&gt;힘이나 변위, 속도(Velocity)를 나타내는 데 쓰인다.&lt;/li&gt;
  &lt;li&gt;힘의 크기를 제외한 순수한 방향만을 표현할 때에도 벡터가 쓰인다.&lt;/li&gt;
  &lt;li&gt;벡터를 시각적으로 표현할 때는 방향이 있는 선분으로 표현한다.&lt;/li&gt;
  &lt;li&gt;선분의 길이는 벡터의 크기를 나타내고, 선분의 화살표 방향은 벡터의 방향을 나타낸다.&lt;/li&gt;
  &lt;li&gt;이 때 벡터를 그리는 위치는 중요하지 않다. 위치 이동은 벡터의 크기와 방향에 영향을 주지 않기 때문이다.&lt;/li&gt;
  &lt;li&gt;벡터는 크기와 방향이 같으면 위치와 상관없이 같은벡터로 인정된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;벡터 수량값의 예로는
힘, 변위, 속도가 있다.&lt;/p&gt;

&lt;h1 id=&quot;힘force&quot;&gt;힘(Force)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;힘은 특정한 방향과 세기로 가해진다.&lt;/li&gt;
  &lt;li&gt;여기서 세기는 힘의 크기를 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;변위displacement&quot;&gt;변위(Displacement)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;한 입자의 최종적인 이동 방향 및 거리&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;속도&quot;&gt;속도&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;빠르기와 방향&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;좌표계&quot;&gt;좌표계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터는 벡터를 기하학적으로 다루지 못하므로, 좌표계를 통해 벡터를 수치적으로 지정한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 17 Oct 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2018/10/17/about-vector.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2018/10/17/about-vector.html</guid>
        
        <category>Direct3d</category>
        
        <category>vector</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>Unity3D Image Component</title>
        <description>&lt;h1 id=&quot;image-component&quot;&gt;&lt;strong&gt;[Image Component]&lt;/strong&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;화면에 텍스쳐를 표시하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;Sprite로 변환된 텍스처만 사용할 수 있다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;property&quot;&gt;&lt;strong&gt;Property&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Source Image : 화면에 표시하려는 이미지(Sprite만 허용)&lt;/li&gt;
  &lt;li&gt;Color : 이미지의 색상 지정(RGBA)&lt;/li&gt;
  &lt;li&gt;Material : 이미지를 렌더링하기 위한 머티리얼(노멀맵 적용 시 사용 가능)&lt;/li&gt;
  &lt;li&gt;Image Type : 이미지를 표시하는 방식으로 4가지 옵션.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Simple
    &lt;ul&gt;
      &lt;li&gt;반복이 필요 없거나 이미지 고정 크기인 경우의 옵션&lt;/li&gt;
      &lt;li&gt;Preserve Aspect를 선택 후 이미지 크기를 조절하면, 원본 이미지의 가로/세로 비율에 맞춰 자동으로 조절된다.&lt;/li&gt;
      &lt;li&gt;또는 모든 UI 항목은 Shift 키를 누른 채 크기 조절을 하면 등비율로 조절된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Sliced
    &lt;ul&gt;
      &lt;li&gt;이미지 리사이즈를 해도 이미지 왜곡이 없이 표현하는 옵션&lt;/li&gt;
      &lt;li&gt;크기를 조절해도 외곽선의 뭉개짐이나 깨짐이 없도록 Sprite Editor를 통해서 설정할 수 있다.&lt;/li&gt;
      &lt;li&gt;말풍선이나 로그인 대화상자 같은 윈도우를 제작할 때 유용하게 사용됨.&lt;/li&gt;
      &lt;li&gt;Fill Center 속성은 가운데 이미지를 채울 것인가에 대한 속성.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Tiled
    &lt;ul&gt;
      &lt;li&gt;이미지를 타일링 처리할 수 있는 옵션&lt;/li&gt;
      &lt;li&gt;이미지 크기가 바뀌어도 동일한 패턴이 크기에 상관없이 반복됨.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Filed
    &lt;ul&gt;
      &lt;li&gt;이미지를 부분적으로 채울 수 있는 옵션&lt;/li&gt;
      &lt;li&gt;특정 방향으로 채워서 그릴 수 있는 것으로, Fill Method  속성에 정의&lt;/li&gt;
      &lt;li&gt;어느 위치에서부터 채워지기 시작하는지는 Fill Origin 속성으로 선택할 수 있다.&lt;/li&gt;
      &lt;li&gt;Clockwise 속성은 시계방향 또는 반대방향을 결정하는 속성이다.&lt;/li&gt;
      &lt;li&gt;Fill Amount 속성은 0.0f ~ 1.0f까지의 값을 지정할 수 있으며, 이미지가 채워지는 비율을 선택하는 속성이다.&lt;/li&gt;
      &lt;li&gt;Filled Image Type은 게임 개발 시 생명 게이지 또는 스킬 버튼의 쿨링타임을 표현할 때 유용하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/Unity/ImageComponent.png&quot; alt=&quot;이해를 돕기 위해 Image Component 이미지를 첨부&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;rawimage-component&quot;&gt;&lt;strong&gt;[RawImage Component]&lt;/strong&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;배경 이미지와 같이 큰 이미지에 사용되는 컴포넌트.&lt;/li&gt;
  &lt;li&gt;Sprite 타입 뿐만 아니라 일반 Texture 타입의 이미지도 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;Sprite Atlas는 포함되지 않는다. (메모리 낭비를 방지하기 위함)&lt;/li&gt;
  &lt;li&gt;UV Rect X, Y 속성은 이미지의 위치를 보정할 수 있는 Offset이다.&lt;/li&gt;
  &lt;li&gt;UV Rect W, H 속성은 가로/세로의 확대 비율이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Unity UI는 Z-Order의 개념을 하이러키 뷰의 순서로 결정한다.&lt;/li&gt;
  &lt;li&gt;하이러키 뷰에 배치된 순서에 따라 Z-Order가 결정되니, UI를 작업할 때는 유의해서 배치해야한다.(큰 UI로 인해 작은 UI가 가려질 수 있음.))&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고 : https://docs.unity3d.com/Manual/script-Image.html&lt;/p&gt;

</description>
        <pubDate>Tue, 14 Aug 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/08/14/about-image.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/08/14/about-image.html</guid>
        
        <category>Unity</category>
        
        <category>Image</category>
        
        <category>UI</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Text Component</title>
        <description>&lt;h1 id=&quot;text-component&quot;&gt;&lt;strong&gt;[Text Component]&lt;/strong&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;사용자에게 텍스트 메시지를 표현할 때 사용하는 컴포넌트.&lt;/li&gt;
  &lt;li&gt;다른 GUI 컴포넌트들과 함께 사용해서 UI를 표현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;property&quot;&gt;&lt;em&gt;Property&lt;/em&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Text : 표시할 텍스트&lt;/li&gt;
  &lt;li&gt;Font : 텍스트에 사용할 폰트&lt;/li&gt;
  &lt;li&gt;Font Size : 표시할 폰트의 크기&lt;/li&gt;
  &lt;li&gt;Line Spacing : 멀티라인의 경우 글자의 상하 사이 간격&lt;/li&gt;
  &lt;li&gt;Rich Text : 입력 텍스트를 마크업 형식으로 표현할 지 여부(마크업 태그 표현 가능)&lt;/li&gt;
  &lt;li&gt;Alignment : 가로, 세로 글 정렬 옵션&lt;/li&gt;
  &lt;li&gt;Horizontal Overflow : Text 가로 영역을 넘어선 글의 처리 방식(Wrap : 자동개행 / Overflow : 범위를 넘어가도록 허용)&lt;/li&gt;
  &lt;li&gt;Vertical Overflow : Text 세로 영역을 넘어선 글의 처리 방식(Wrap / Overflow)&lt;/li&gt;
  &lt;li&gt;Best fit : Font Size를 무시하고 Text 컴포넌트의 범위에 맞게 크기를 조정한다.&lt;/li&gt;
  &lt;li&gt;Color : Text 색상&lt;/li&gt;
  &lt;li&gt;Material : Text에 별도의 머티리얼을 적용할 수 있다.
&lt;br /&gt;
    &lt;h2 id=&quot;text-effect&quot;&gt;&lt;em&gt;Text Effect&lt;/em&gt;&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;Shadow 컴포넌트를 새로 추가함으로써, Text에 그림자 효과를 추가할 수도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/Unity/textcomponent.png&quot; alt=&quot;이해를 돕기 위해 Text Component 이미지를 첨부&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고 : https://docs.unity3d.com/Manual/script-Text.html&lt;/p&gt;

</description>
        <pubDate>Mon, 13 Aug 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/08/13/about-text.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/08/13/about-text.html</guid>
        
        <category>Unity</category>
        
        <category>Text</category>
        
        <category>UI</category>
        
        <category>Component</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Button Component</title>
        <description>&lt;h1 id=&quot;button-component&quot;&gt;&lt;strong&gt;[Button Component]&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;컴포넌트의 이름에 맞게 Button Component가 추가된 UI를 사용자가 누를 경우 이벤트를 실행할 수 있도록 설계된 Component다.&lt;/li&gt;
  &lt;li&gt;Web Form의 Submit 또는 Cancel과 유사한 컴포넌트.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;property&quot;&gt;&lt;em&gt;Property&lt;/em&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Interactable : Button 기능을 활성/비활성화 한다. Transition 속성이 Animation일 경우 이 옵션을 언체크하면 Disabled Trigger가 발생한다.&lt;/li&gt;
  &lt;li&gt;Transition
    &lt;ul&gt;
      &lt;li&gt;버튼은 Normal, Highlighted, Pressed, Disabled 총 4가지의 상태를 가지고 있다.&lt;/li&gt;
      &lt;li&gt;이 때, 버튼의 클릭, 롤오버, 비활성화 등의 상태 및 버튼의 외형의 변화를 어떻게 변경할 것인지 설정한다.[None/ColorTint/SpriteSwap/Animation]&lt;/li&gt;
      &lt;li&gt;None : 버튼 상태가 바뀌어도 아무런 변화가 없다.&lt;/li&gt;
      &lt;li&gt;Color Tint : 버튼 상태에 따라 색상의 변화를 준다. Color Multiplier로 변하는 색상의 농도를 조절할 수 있다. Fade Duration은 다른 상태로 페이드인, 아웃 되는 시간을 조절할 수 있다.&lt;/li&gt;
      &lt;li&gt;SpriteSwap : 버튼 상태에 따라 이미지를 변경한다. 기존의 Target Graphic은 Normal상태의 이미지로 지정되고, 그 외 상태일 때의 이미지를 지정할 수 있는 속성이 추가된다.&lt;/li&gt;
      &lt;li&gt;Animation : 애니메이션 효과를 적용할 수 있으며, ‘Auto Generate Animation’ 버튼을 누를 경우 애니메이션 컨트롤러가 자동 생성된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Navigation
    &lt;ul&gt;
      &lt;li&gt;키보드 입력 포커스를 받은 후 키를 통해 다음 버튼으로 이동하는 방식을 설정한다.&lt;/li&gt;
      &lt;li&gt;None : 포커스 이동 기능을 사용하지 않는다.&lt;/li&gt;
      &lt;li&gt;Horizontal : 좌우 화살표 키만 허용한다.&lt;/li&gt;
      &lt;li&gt;Vertical : 상하 화살표 키만 허용한다.&lt;/li&gt;
      &lt;li&gt;Automatic : 상하좌우 화살표 키를 모두 사용하며 자동으로 이동 순서가 결정된다.&lt;/li&gt;
      &lt;li&gt;Explict : 포커스 이동을 직접 선택할 수 있으며, 전후좌우 방향 이동이 자유롭다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OnClick : 버튼을 클릭했을 때 수행할 함수를 연결하는 이벤트 속성이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/static/assets/img/blog/Unity/buttoncomponent.png&quot; alt=&quot;이해를 돕기 위해 Button Component 이미지를 첨부&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고 : https://docs.unity3d.com/Manual/script-Button.html&lt;/p&gt;

</description>
        <pubDate>Mon, 13 Aug 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/08/13/about-button.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/08/13/about-button.html</guid>
        
        <category>Unity</category>
        
        <category>Button</category>
        
        <category>UI</category>
        
        <category>Component</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Photon Server</title>
        <description>&lt;p&gt;최종 수정일 : 2018-08-04&lt;/p&gt;

&lt;h1 id=&quot;photon-server&quot;&gt;&lt;em&gt;Photon Server&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;이번에 작성할 내용은 unity 클라이언트와 연동해서 사용할 ‘Photon’ 이라는 상용 네트워크 서비스 엔진입니다. Unreal Engine과도 연동이 되는 것으로 알고 있지만, 제가 사용할 곳은 Unity이기 때문에 그에 맞게 스터디 해볼 예정입니다. 이번에 회사에서 포톤 서버를 사용할 일이 생겨서 스터디하면서 기본 개념에 대해 정리해보고자 합니다.
기본 개념은 대체로 포톤 공식 홈페이지에 적혀있는 내용을 기반으로 작성되었으며, 번역이 이상할 수도 있으니 틀린점 있으면 댓글로 알려주시면 수정하겠습니다. 클라이언트 개발자로서 서버에 대한 이해도가 많이 낮은 상태에서 작성된 점 양해부탁드립니다.
 추가적인 부분은 지속적으로 수정해가며 업데이트할 예정입니다. 감사합니다.&lt;/p&gt;

&lt;p&gt;###작업 환경&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Windows 10&lt;/li&gt;
  &lt;li&gt;Unity 2018.1.5f1&lt;/li&gt;
  &lt;li&gt;Visual Studio 10 / ATOM&lt;/li&gt;
  &lt;li&gt;Photon-OnPremise-Server-SDK_v4-0-29-11263&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;환경-구축-순서&quot;&gt;환경 구축 순서&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Windows10 IIS 설치&lt;/li&gt;
  &lt;li&gt;Photon SDK 설치&lt;/li&gt;
  &lt;li&gt;포톤sdk설치폴더\deploy\bin_Win64\PhotonControl.exe 실행&lt;/li&gt;
  &lt;li&gt;Visual Studio에서 콘솔 응용프로그램 프로젝트를 생성한다.&lt;/li&gt;
  &lt;li&gt;생성한 프로젝트에서 프로젝트(P) 탭의 “생성한 프로젝트이름” 속성 페이지로 들어간다.&lt;/li&gt;
  &lt;li&gt;응용 프로그램 탭에서 대상 프레임 워크를 .NET Framework로 맞추고, 출력 형식을 클래스 라이브러리로 설정한다.&lt;/li&gt;
  &lt;li&gt;프로젝트의 참조에 Photon에 관련된 dll 파일들을 Import 시킨다.&lt;/li&gt;
  &lt;li&gt;참조할 dll 파일은 Photon SDK를 설치한 폴더의 lib 폴더 안에 보면 준비되있다.&lt;/li&gt;
  &lt;li&gt;Logging.Log4Net / SocketServer / PhotonHostRuntimeInterfaces / Libs 등등&lt;/li&gt;
  &lt;li&gt;PhotonSDK폴더\deploy\ 에 내가 생성한 서버 프로젝트 이름의 폴더를 새로 생성 한후, 그 안에 bin 폴더를 생성한다.&lt;/li&gt;
  &lt;li&gt;서버 로직을 구현한 후, 서버 프로젝트를 빌드한 후 생긴 파일들을 ‘h’에서 생성한 bin 폴더 안에 넣는다.&lt;/li&gt;
  &lt;li&gt;PhotonSDK폴더\deploy\bin_Win64 폴더 안에 있는 PhotonServer.config를 편집기로 실행해서,  Configuration 태그 안에 예제 프로젝트를 입력한 것과 동일한 방식으로 내 프로젝트에 맞게 값을 입력한다.&lt;/li&gt;
  &lt;li&gt;PhotonControl을 재시작하면 config파일 안에 입력한 내 프로젝트가 생성되있는데, 거기서 install Service를 한 뒤에, start Service한다.&lt;/li&gt;
  &lt;li&gt;이제 포톤 서버가 제대로 실행되고 있는 것이다.
&lt;br /&gt;
    &lt;h2 id=&quot;환경-구축-순서클라이언트&quot;&gt;환경 구축 순서(클라이언트)&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;유니티의 File탭 -&amp;gt; Build Settings -&amp;gt; Player Settings -&amp;gt; Resolution and Presentation에 들어가서 Run In Background 옵션을 켜준다.&lt;/li&gt;
  &lt;li&gt;프로젝트의 assets 폴더 안에 plugins 폴더를 만들어서 그 안에 PhotonSDK 폴더 안에 있는 Photon3Unity3D.dll 파일을 추가한다.&lt;/li&gt;
  &lt;li&gt;plugins 폴더를 추가할 경우, 이는 Unity에서 빌드할 때 사용되는 예약어로, 자동으로 dll 파일(네이티브 라이브러리)가 빌드에 포함될 것이다.&lt;/li&gt;
  &lt;li&gt;이후, 서버와의 통신 관련해서는 Photon library를 using문에 추가한 후 사용하면 될 것.
&lt;br /&gt;
    &lt;h2 id=&quot;photon-application-응용-프로그램&quot;&gt;Photon Application 응용 프로그램&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;Application은 서버 쪽에서 실행하는 게임 로직이며, 게임 내 특화된 기능(RPC, Data Storing, DB, etc..)이 Photon Application에서 구현되는 것.&lt;/li&gt;
      &lt;li&gt;C# Base로 로직을 구현하게 되며, 실행할 경우 DLL 파일이 생성되어 Photon 소스를 중심으로 로딩 후 실행된다. Photon Core에서 설정 파일 Configuration files를 읽어오고, 로딩 시 초기화와 일부 응용프로그램 관련 매개 변수를 편집.&lt;/li&gt;
      &lt;li&gt;일반적으로, 한 Application에서 하나의 게임 내 운영 로직 모두를 제공.
&lt;br /&gt;
        &lt;h2 id=&quot;game-logic&quot;&gt;Game Logic&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;클라이언트와 서버간 상호 정보 전달 방법 및 기능에 관한 것으로, 조작/이벤트 및 서버 자체 또는 외부와의 연결에서 반드시 실행해야 할 관련 과정을 구현해난다.&lt;/li&gt;
      &lt;li&gt;SocketServer에 대한 정보로는 photon.Socketserver.dll에 정의되어 있어서 참고 가능하다.
&lt;br /&gt;
        &lt;h2 id=&quot;operation&quot;&gt;Operation&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;Photon에서의 Operation은 RPC 구조와 동일하기 때문에, 클라이언트에서 operation call로 그들 간의 통신 전달 기능을 이용할 수 있다.&lt;/li&gt;
      &lt;li&gt;매개 변수 전송은 서버쪽 애플리케이션에서 HashTable(keys &amp;amp; values)를 통한 데이터를 정의해놓은 후, 클라이언트와 서버 간의 직렬화(Serialize), 전송(Transfer) 및 비직렬화(Deserialize)를 진행한다.&lt;/li&gt;
      &lt;li&gt;매 Operation call마다 리턴값은 서버가 클라이언트에게 보내주는 단방향 통신을 사용할 때 제공합니다.
&lt;br /&gt;
        &lt;h2 id=&quot;events&quot;&gt;Events&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;클라이언트에게 보내는 Message Notification.&lt;/li&gt;
      &lt;li&gt;클라이언트에서도 이벤트를 자체 설계해서 서버에게 보낼 수 있다.&lt;/li&gt;
      &lt;li&gt;일반적으로 Event가 생성 또는 발생 될 경우, 해당 이벤트를 수신하고 있는 모든 클라이언트에게 이벤트가 전달된다.
&lt;br /&gt;
        &lt;h2 id=&quot;connections--timeouts&quot;&gt;Connections &amp;amp; Timeouts&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;Reliable-UDP(R-UDP, 개량형 UDP)를 사용한다.&lt;/li&gt;
      &lt;li&gt;Sender에서 송출한 R-UDP의 패킷 내 commands에 시리얼 번호 및 flag를 가지고 있으며, Receiver에서는 반드시 해당 신호에 등답해야한다.&lt;/li&gt;
      &lt;li&gt;발송 지점 R-UDP는 단시간 내재발송이 진행되며, 상대방의 Response가 도착해야 중지된다.&lt;/li&gt;
      &lt;li&gt;Response를 수신하지 못할 경우, Timeout error message 생성&lt;/li&gt;
      &lt;li&gt;Timeout이 발생할 경우, 바로 해당 연결을 끊으며, 정보동기화가 발생하지 않습니다.
&lt;br /&gt;
        &lt;h2 id=&quot;mmo-application&quot;&gt;MMO Application&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;Actors / Items / Properties / Events의 기본 유형으로 구성되어있습니다.&lt;/li&gt;
      &lt;li&gt;구역은 World / Region / InterestArea / Item 으로 구분됩니다.
 &lt;br /&gt;
        &lt;h2 id=&quot;peers&quot;&gt;Peers&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;서버와 연결한 사용자의 Instance&lt;/li&gt;
      &lt;li&gt;App에 연결한 클라이언트 네트워크가 있다면, CreatePeer는 그에 상응하는 Peer를 만들고, 해당 클라이언트에서 전해오는 Operations 모두 그에 상응하는 Peer에서 처리하게 된다.&lt;/li&gt;
      &lt;li&gt;App 내의 매 Peer 마다 상태 지시의 RoomReference가 존재한다.&lt;/li&gt;
      &lt;li&gt;Join Room을 할 때, 해당 상태 지시 기능이 생성된다.&lt;/li&gt;
      &lt;li&gt;Peer 연결이 끊어질 경우, OnDisconnect를 호출한다.&lt;/li&gt;
      &lt;li&gt;서버와 통신할 클라이언트의 객체는 IPhotonPeerListener를 상속받아서 구현한다.
&lt;br /&gt;
        &lt;h2 id=&quot;oneventeventdata-eventdata&quot;&gt;OnEvent(EventData eventData)&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;서버에서 Broadcast를 통해 클라에게 데이터를 전달할 경우, 클라이언트에서 호출되는 메소드. eventData는 서버에서 전달하는 데이터를 담고 있는 객체
&lt;br /&gt;
        &lt;h2 id=&quot;onoperationresponseoperationresponse-operationresponse&quot;&gt;OnOperationResponse(OperationResponse operationResponse)&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;서버에서 특정 클라에게 데이터를 전달할 경우, 클라이언트에서 호출되는 메소드. operationResponse는 서버에서 전달하는 데이터를 담고 있는 객체	
&lt;br /&gt;
        &lt;h2 id=&quot;onstatuschangedstatuscode-statuscode&quot;&gt;OnStatusChanged(StatusCode statusCode)&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;서버에서 상태가 변경될 때 호출되는 메소드.&lt;/li&gt;
      &lt;li&gt;Connect, Disconnect, Timeout, etc…
 &lt;br /&gt;
        &lt;h2 id=&quot;debugreturndebuglevel-level-string-message&quot;&gt;DebugReturn(DebugLevel level, string message)&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;디버그 메시지를 리턴해주는 메소드.
&lt;br /&gt;
        &lt;h2 id=&quot;photonpeer-객체&quot;&gt;PhotonPeer 객체&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;PhotonPeer 클래스는 Photon Server와 연결하고, communicate 하는데 사용되는 클래스입니다.&lt;/li&gt;
      &lt;li&gt;이는 Photon Server 뿐만 아니라, Server 내에 있는 또다른 PhotonPeer 클래스와 Communicate 하는데도 마찬가지입니다.&lt;/li&gt;
      &lt;li&gt;한 어플리케이션에서 하나 이상의 PhotonPeer를 사용할 경우, 각각 다르게 event 또는 operation에 대한 요청/응답을 설정 할 수 있습니다.
&lt;br /&gt;
        &lt;h2 id=&quot;rooms&quot;&gt;Rooms&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;한 Room 당 플레이어 수가 제한되어 있다.&lt;/li&gt;
      &lt;li&gt;Room에는 하나 이상의 Peer가 존재하게 되며, 그 안에서 함께 데이터를 주고받으면서 게임이 시작된다.&lt;/li&gt;
      &lt;li&gt;일반적으로 룸 안에서 모든 사람은 다른 사람이 전송한 것을 수신한다.&lt;/li&gt;
      &lt;li&gt;룸으로 플레이어를 접속하게 하는 방법은 무작위 매치메이킹 / 특정 Properties를 가진 룸에 플레이어를 접속하게 하는방법 두가지이다.&lt;/li&gt;
      &lt;li&gt;Room끼리(각각의 Game)는 서로 완벽하게 독립된다.&lt;/li&gt;
      &lt;li&gt;Room은 모두 고유 식별자로서 이름을 가지고 있다.&lt;/li&gt;
      &lt;li&gt;Request는 받은 순서대로 처리된다.&lt;/li&gt;
      &lt;li&gt;각 Room마다 모두 Balacing이 존재해서 Request마다 매 tick마다 처리되기 때문에 거의 실시간에 가까운 처리가 진행되며, 이후 프레임 확장에 사용할 수 있다.&lt;/li&gt;
      &lt;li&gt;Room 내 사용자 모두 Actor로 표시되고, Actor마다 ActorNumber를 가지고 있어, Event를 전송할 때마다, 해당 값으로 발송자를 식별할 수 있다.&lt;/li&gt;
      &lt;li&gt;마스터 서버는 App을 통해 Room의 목록을 제공해 줄 수 있다.
&lt;br /&gt;
        &lt;h2 id=&quot;robby&quot;&gt;Robby&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;마스터 서버에 존재하며, 게임의 룸 목록을 제공한다.&lt;/li&gt;
      &lt;li&gt;아직 룸에 참여하지 않은 플레이어들이 모여서, 룸에 접속하기 위해 대기하는 장소.
&lt;br /&gt;
        &lt;h2 id=&quot;handleraiseevent&quot;&gt;HandleRaiseEvent&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;서버에서도 필요에 따라 모든 이벤트를 전송할 수 있는 이벤트.
&lt;br /&gt;
        &lt;h2 id=&quot;properties&quot;&gt;Properties&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;HashTable을 대표하는 구조.&lt;/li&gt;
      &lt;li&gt;사용자의 데이터 설정 및 inout 작업에 용이함.&lt;/li&gt;
      &lt;li&gt;보통 Actor 또는 Room에 추가.&lt;/li&gt;
      &lt;li&gt;룸 내 일부 데이터 및 사용자 이름 설정에 사용할 수 있고, 클라이언트 데이터 획득도 가능.&lt;/li&gt;
      &lt;li&gt;SetProperties / GetProperties 로 관련 데이터를 set/get할 수 있다.&lt;/li&gt;
      &lt;li&gt;Room에 Join할 때 기존에 설정한 Room Data를 덮어쓰기 하는데, 새로운 Room을 생성해 Join을 진행해야만 데이터를 설정할 수 있고, 이후에 Room에 Join한 사람이 하는 설정은 무효가 된다.
&lt;br /&gt;
        &lt;h2 id=&quot;photon-plugin&quot;&gt;Photon Plugin&lt;/h2&gt;
      &lt;/li&gt;
      &lt;li&gt;사용자 정의 서비스 로직을 추가하고 싶을 때, Photon Server에 정의해 놓은 인터페이스(Hook)에 Injection해줘야한다.&lt;/li&gt;
      &lt;li&gt;Photon Plugin마다 각각의 식별자가 있으며, Event에 상응하는 CallBack을 구현해야 한다.
&lt;br /&gt;
        &lt;h2 id=&quot;photon-server-method&quot;&gt;Photon Server Method&lt;/h2&gt;
        &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
        &lt;h3 id=&quot;intercept-the-hook-call&quot;&gt;Intercept the hook call&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;콜백 발생 시, 호스트에서 통제권을 Plugin으로 보냄.
&lt;br /&gt;
        &lt;h3 id=&quot;alter-call-info-option&quot;&gt;Alter call info (Option)&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;실제로 hook call을 실행하기 전에, 클라이언트/서버에서 송출하는 Request를 액세스하고 수정한다.
&lt;br /&gt;
        &lt;h3 id=&quot;inject-custom-code-option&quot;&gt;Inject custom code (Option)&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;Hook call을 실행하기 전에 호스트와 일부 과정을 처리한다.
ex) HTTP Request, Look up room/actor Reference, Count 값 설정 etc..
&lt;br /&gt;
        &lt;h3 id=&quot;process-hook-call&quot;&gt;Process hook call&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;실제로 해당 요청 처리 방법(장소)을 결정한다.&lt;/li&gt;
      &lt;li&gt;ICallInfo Processing Method 참조
&lt;br /&gt;
        &lt;h3 id=&quot;inject-custom-code-option-1&quot;&gt;Inject custom code (Option)&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;실행 후, 클라이언트/서버에서 송출한 요청이 Read Only로 변경됨.&lt;/li&gt;
      &lt;li&gt;단, 처리 실행 후 플러그인은 여전히 호스트와 상호 작용한다.
&lt;br /&gt;
        &lt;h3 id=&quot;return&quot;&gt;Return&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;플러그인 통제권을 호스트에 반환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/08/04/about-photon.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/08/04/about-photon.html</guid>
        
        <category>Unity</category>
        
        <category>Canvas</category>
        
        <category>EventSystem</category>
        
        <category>Rect Transform</category>
        
        <category>Anchor</category>
        
        <category>Component</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Canvas</title>
        <description>&lt;p&gt;최종 수정일 : 2018-08-13
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;gameobject-canvas&quot;&gt;&lt;strong&gt;GameObject Canvas&lt;/strong&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Unity에서 모든 UI Element(텍스트, 이미지, 버튼, 슬라이더 등)는 반드시 이 Canvas 객체 하위에 위치해야만 한다.&lt;/li&gt;
  &lt;li&gt;Rect Transform, Canvas, Canvas Scaler, Graphic Raycaster. 총 4개의 컴포넌트로 구성된 GameObject.&lt;/li&gt;
  &lt;li&gt;한 Scene에서 여러개 생성하거나 다른 Canvas 객체의 하위로 차일드화 할 수 있다.&lt;/li&gt;
  &lt;li&gt;Hierarchy View에 Canvas를 생성할 경우, Event System도 자동으로 생성된다.
&lt;br /&gt;
    &lt;h2 id=&quot;eventsystem&quot;&gt;EventSystem&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;시스템에서 발생하는 키보드, 조이스틱, 스크린터치 등의 입력 정보를 Canvas 하위에 있는 UI 항목에 전달하는 역할.&lt;/li&gt;
  &lt;li&gt;Standalone Input Module 컴포넌트를 포함하고 있다.&lt;/li&gt;
  &lt;li&gt;First Selected 속성을 통해 처음 포커스를 갖는 UI 항목을 지정할 수 있다.&lt;/li&gt;
  &lt;li&gt;EventSystem이 없다면, UI 항목이 클릭 또는 터치와 같은 이벤트에 반응하지 않는다.
&lt;br /&gt;
    &lt;h2 id=&quot;rect-transform&quot;&gt;Rect Transform&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Canvas 및 UI 항목에 자동적으로 추가되어있다.&lt;/li&gt;
  &lt;li&gt;앵커(Anchors), 피봇(Pivot), 크기(W, H), 위치(Pos X, Pos Y, Pos Z)와 회전 및 스케일 정보를 저장하고 있다.&lt;/li&gt;
  &lt;li&gt;UI용 Transform 컴포넌트 / 기존 Transform 컴포넌트와 동일한 역할&lt;/li&gt;
  &lt;li&gt;속성을 직접 수정할 수 없으며, 화면의 크기에 따라 자동으로 설정된다.
&lt;br /&gt;
    &lt;h2 id=&quot;anchor-point&quot;&gt;Anchor Point&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;UI 항목 상위의 Canvas 영역을 기준으로 표시하는 것.&lt;/li&gt;
  &lt;li&gt;UI 항목의 정렬(Align)과 크기 조절(Stretch)을 설정한다.&lt;/li&gt;
  &lt;li&gt;앵커 포인트는 각각 4개의 삼각형으로 구성돼 있으며, 각각 개별적으로 움직일 수 있다.&lt;/li&gt;
  &lt;li&gt;앵커 포인트는 UI 항목 자기 자신의 Rect Transform이 기준이 아니라 그 상위 객체의 Rect Transform을 기준으로 삼는다.
&lt;br /&gt;
    &lt;h2 id=&quot;anchors-min--max&quot;&gt;Anchors Min &amp;amp; Max&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;앵커 값의 범위를 나타내며, % float 형식의 값이 들어가며, %로 표현된다.&lt;/li&gt;
  &lt;li&gt;Pivot
&lt;br /&gt;
    &lt;h2 id=&quot;anchor-preset&quot;&gt;Anchor Preset&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;각 UI 항목의 정렬과 크기를 미리 정의해놓은 집합.&lt;/li&gt;
  &lt;li&gt;UI 항목의 Inspector View의 Rect Transform의 가장 왼쪽에 있는 것.&lt;/li&gt;
  &lt;li&gt;UGUI의 기본이 되는 개념&lt;/li&gt;
  &lt;li&gt;앵커 프리셋은 각각 일반 마우스를 클릭했을 때와 Alt 키와 Shift키의 조합에 따라 다른 조합을 볼 수 있다. [Alt + Click] [Shift + Click] [Alt + Shift + Click]
&lt;br /&gt;
    &lt;h2 id=&quot;anchoredposition&quot;&gt;anchoredPosition&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Rect Transform 속성 맨 위에 있는 Pos X, Pos Y, Pos Z는 해당 UI 항목의 ‘앵커 포인트를 기준’으로 상대적으로 얼마만큼 떨어져 있는지를 나타내는 anchoredPosition이다.
&lt;br /&gt;
    &lt;h2 id=&quot;canvas-component&quot;&gt;Canvas Component&lt;/h2&gt;
    &lt;ol&gt;
      &lt;li&gt;UI 항목을 화면에 배치하고 렌더링하는 역할.&lt;/li&gt;
      &lt;li&gt;Render Mode 옵션에 따라 UI 항목의 화면 배치 방식을 결정할 수 있다.&lt;/li&gt;
      &lt;li&gt;Screen Space - Overlay&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 설정값으로 UI 항목은 씬의 가장 상위 계층에서 표현되며, 화면의 해상도에 맞춰 자동으로 스케일이 조절된다.
    &lt;ol&gt;
      &lt;li&gt;Screen Space - Camera&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;씬의 가장 상위에 UI 항목이 표시되는 것은 Overlay방식과 같지만, UI 항목을 렌더링하는 별도의 카메라를 설정할 수 있다.&lt;/li&gt;
  &lt;li&gt;씬을 비추는 Main Camera와 UI를 위한 카메라로 이원화할 수 있다.&lt;/li&gt;
  &lt;li&gt;Render Camera 속성에 원하는 카메라를 연결하면 된다.&lt;/li&gt;
  &lt;li&gt;UI Camera의 Projection 속성을 Perspective로 설정&lt;/li&gt;
  &lt;li&gt;UI Camera를 따로 설정할 경우, Main Camera와 충돌이 없도록 반드시 Clear Flag, Culling Mask, Depth속성을 적절히 설정해야 한다.
    &lt;ol&gt;
      &lt;li&gt;World Space&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;씬 내에 있는 다른 게임오브젝트에 직접 UI 항목을 추가한다.&lt;/li&gt;
  &lt;li&gt;대표적으로 HUD(Head Up Display)를 구현할 때 사용.&lt;/li&gt;
  &lt;li&gt;특정 게임오브젝트에 Canvas 객체를 추가하고 Render Mode를 World Space로 설정하면 해당 Canvas는 더는 Rect Transform의 영향을 받지 않으며, 해당 게임오브젝트의 위치에 영향을 받는다.
&lt;br /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/canvas1.png&quot; alt=&quot;Canvas Component Render Mode 변경에 따른 내용&quot; /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/canvas2.png&quot; alt=&quot;Canvas Component Render Mode 변경에 따른 내용&quot; /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/canvas3.png&quot; alt=&quot;Canvas Component Render Mode 변경에 따른 내용&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/08/04/about-canvas.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/08/04/about-canvas.html</guid>
        
        <category>Unity</category>
        
        <category>Canvas</category>
        
        <category>EventSystem</category>
        
        <category>Rect Transform</category>
        
        <category>Anchor</category>
        
        <category>Component</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D C# Delegate</title>
        <description>&lt;p&gt;최종수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;delegate&quot;&gt;Delegate&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;메소드에 대한 참조를 나타내는 방&lt;/li&gt;
  &lt;li&gt;메소드 대신해서 호출하는 역할
    &lt;ul&gt;
      &lt;li&gt;메소드의 대리인 역할을 해주는 변수&lt;/li&gt;
      &lt;li&gt;메소드를 직접적으로 호출하는 방식이 아닌, 델리게이트를 호출함으로써 해당 메소드를 호출(실행)할 수 있는 방식.&lt;/li&gt;
      &lt;li&gt;델리게이트를 ‘인스턴스화’ 하면 호환되는 파라미터 타입/개수와 리턴 타입이 같은 모든 메소드를 참조할 수 있게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C++의 함수 포인터와 동일한 형태로 사용가능하지만, 안전하게 캡슐화하여 사용할 수 있다는 장점이 있다.&lt;/li&gt;
  &lt;li&gt;콜백(CallBack) 메소드를 구현할 때 효율적이다.
    &lt;ul&gt;
      &lt;li&gt;CallBack Method란?&lt;/li&gt;
      &lt;li&gt;A 메소드를 호출할 때 B 메소드를 넘겨줘서 A 메소드로 하여금 B 메소드를 호출하도록 하는 것. 이 때 A 메소드를 콜백 메소드라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Delegate Chain : 하나의 델리게이트에 여러개의 메소드를 연결시키는 것.
함수를 멀티캐스트(Multicast)할 때 사용하면 유용하다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;예제-코드&quot;&gt;&lt;em&gt;예제 코드&lt;/em&gt;&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;

using System.Collections;

public class DelegateTest : MonoBehavior
{
    // 델리게이트에 연결할 함수의 원형 정의
    delegate void CalNumDelegate(int num);


    // 델리게이트 변수 선언
    CalNumDelegate calNum;

    void Start()
    {
        // calNum 델리게이트 변수에 OnePlusNum 함수 연결
        calNum = OnePlusNum;
        // 함수 호출
        calNum(4);


        // calNum 델리게이트 변수에 PowerNum 함수 연결
        calNum = PowerNum;

        // 함수 호출
        calNum(5);
    }

    void OnPlusNum(int num)
    {
        int result = num + 1;
        Debug.Log(“One Plus = “ +result);
    }

    void PowerNum(int num)
    {
        int result = num * num;
        Debug.Log(“Power = “ +result);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;event와-delegate의-차이점&quot;&gt;Event와 Delegate의 차이점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;델리게이트가 public이라면, 이벤트 변수는 private 같은 느낌이다.&lt;/li&gt;
  &lt;li&gt;델리게이트 변수는 자신이 속한 클래스 외부에서도 호출이 가능하다.&lt;/li&gt;
  &lt;li&gt;이벤트 변수는 외부에서 호출이 불가능하고, 변수가 속한 클래스 내부에서만 사용하도록 제한되어있다.&lt;/li&gt;
  &lt;li&gt;이벤트는 특정 조건(사건)이 발생했을 때 자동으로 메소드를 호출하는 용도로 사용된다.
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;func--action&quot;&gt;Func &amp;amp; Action&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;무명 델리게이트&lt;/li&gt;
  &lt;li&gt;미리 선언된 델리게이트 변수로써, 별도의 선언없이 사용가능하다.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;func-delegate&quot;&gt;Func Delegate&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Func은 반환값(Return Type)이 ‘있는’ 메소드를 참조하는 델리게이트 변수&lt;/li&gt;
  &lt;li&gt;.NET Framework에는 매개변수가 없는 메소드부터 매개변수가 16개인 메소드까지 총 17가지의 Func 델리게이트가 준비되어있다.&lt;/li&gt;
  &lt;li&gt;Func Delegate를 사용할 때는 반드시 반환형을 지정해줘야 한다.
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;action-delegate&quot;&gt;Action Delegate&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Action은 반환값(Return Type)이 ‘없는’메소드를 참조하는 델리게이트 변수&lt;/li&gt;
  &lt;li&gt;Func Delegate와 그 쓰임새나 형식은 같으나, 반환값(Return Value)가 없다.
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;람다식-lamda&quot;&gt;람다식 (Lamda)&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;무명 메소드를 단순 계산식으로 표현한 것.&lt;/li&gt;
  &lt;li&gt;메소드는 크게 매개변수와 내부 식, 반환 값으로 구성되어있는데, 이들만 가지고 메소드를 계산으로 표현한다.&lt;/li&gt;
  &lt;li&gt;추후에 좀 더 자세하게 알아볼 필요성이 있음.
Ex) button.addListener(() =&amp;gt; 메소드명);&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 30 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/30/about-delegate.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/30/about-delegate.html</guid>
        
        <category>Unity</category>
        
        <category>Delegate</category>
        
        <category>Event</category>
        
        <category>Action</category>
        
        <category>Func</category>
        
        <category>C#</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Generic Collection, Boxing and Unboxing</title>
        <description>&lt;p&gt;최종 수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;일반화-컬렉션&quot;&gt;&lt;strong&gt;일반화 컬렉션&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;종류 : List, Queue, Stack, Dictionary&lt;/li&gt;
  &lt;li&gt;ArrayList, Queue, Stack, HashTable의 일반화 버전&lt;/li&gt;
  &lt;li&gt;using System.Collection.Generic; 네임스페이스 안에 존재하기 때문에 사용 선언 필수.
&lt;br /&gt;
    &lt;blockquote&gt;
      &lt;p&gt;일반화 컬렉션(Generic Collection)을 사용하는 이유.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;C# 언어 내부에서 제공하는 Collection(Stack, Queue, ArrayList, HashTable)에 데이터의 입, 출력이 있으면 그때마다 박싱과 언박싱이 계속해서 발생하게 되고, 데이터가 많아질수록 컴퓨터 성능에 상당한 부하가 발생하게 된다.&lt;/li&gt;
  &lt;li&gt;부하가 발생하는 원인 : 컬렉션은 데이터의 어떤 타입도 전부 object 타입으로 저장하기 때문에, 데이터에 접근할 때마다 본래 타입으로의 형식변환이 일어나기 때문이다. =&amp;gt; Boxing과 UnBoxing.&lt;/li&gt;
  &lt;li&gt;성능 상의 이슈가 문제가 된다면, 컬렉션보단 일반화 컬렉션(Generic Collection)을 사용하기로 한다.
&lt;br /&gt;
&lt;br /&gt;
    &lt;h1 id=&quot;boxing&quot;&gt;&lt;strong&gt;Boxing&lt;/strong&gt;&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;값(Value) 형식을 Object형식 또는 이 값 형식에서 구현된 임의의 인터페이스 형식으로 변환하는 프로세스.&lt;/li&gt;
  &lt;li&gt;값 형식을 참조 형식으로 바꾸는 것.&lt;/li&gt;
  &lt;li&gt;메모리의 Stack 영역에서 Heap 영역으로 데이터가 복사되고, 그 복사된 데이터를 object가 참조하게 한다.(값 형식 -&amp;gt; 참조 형식)&lt;/li&gt;
  &lt;li&gt;암시적이다.
 &lt;img src=&quot;/static/assets/img/blog/Unity/boxing.png&quot; alt=&quot;Boxing의 예시&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
    &lt;h1 id=&quot;unboxing&quot;&gt;&lt;strong&gt;UnBoxing&lt;/strong&gt;&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;Boxing된 데이터를 Heap 영역에서 Stack영역으로 복사한다.(참조 형식 -&amp;gt; 값 형식)&lt;/li&gt;
  &lt;li&gt;명시적이다.
&lt;img src=&quot;/static/assets/img/blog/Unity/unboxing.png&quot; alt=&quot;UnBoxing의 예시&quot; /&gt;
&lt;br /&gt;
참고 : https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/types/boxing-and-unboxing&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 28 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/28/about-boxing-unboxing.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/28/about-boxing-unboxing.html</guid>
        
        <category>Unity</category>
        
        <category>Generic Collection</category>
        
        <category>Boxing</category>
        
        <category>unboxing</category>
        
        <category>일반화 콜렉션</category>
        
        <category>C#</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Quaternion Component</title>
        <description>&lt;p&gt;최종 수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;quaternion&quot;&gt;&lt;em&gt;&lt;strong&gt;Quaternion&lt;/strong&gt;&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;-quaternion-이란--&quot;&gt;&lt;em&gt;&lt;strong&gt;[ Quaternion 이란 ? ]&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;유니티에서 사용되는 각도의 단위&lt;/li&gt;
  &lt;li&gt;유니티에서 회전을 표현하기 위해 사용되는 구조체(Struct)&lt;/li&gt;
  &lt;li&gt;수학적인 용어로 복소수 4차원 벡터(Four-Deminsional Complex Number)
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;각도를 4개의 원소로 표현한 것. ( = 사원수)
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;x, y, z, w로 표현되어 있음.
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;우리가 알고 있는 1도, 45도, 90도 등의 표현은 오일러 각(Euler Angle)이라고 한다.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;-quaternion이-나오게-된-이유-&quot;&gt;&lt;em&gt;&lt;strong&gt;[ Quaternion이 나오게 된 이유 ]&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;오일러 각은 3차원 공간의 절대 좌표를 기준으로 물체가 얼마나 회전했는지 측정하는 방식이다.&lt;/li&gt;
  &lt;li&gt;오일러 각은 회전 시킬 때, X, Y, Z 축을 차례대로 회전 시키는 방식을 사용하고 있다.&lt;/li&gt;
  &lt;li&gt;이 때 X, Y, Z 축 중 2개의 축이 겹쳐 졌을 때 어느 축으로도 회전되지 않고 잠기는 현상이 발생하는데, 이를 짐벌락(Gimbal Lock)이라고 한다.&lt;/li&gt;
  &lt;li&gt;유니티에서는 이 짐벌락 현상을 해결하기 위해 Quaternion이 제시되어, 세 축을 차례대로 회전시키는 것이 아닌, 세 축을 동시에 회전시키는 방식을 사용하고 있다.&lt;/li&gt;
  &lt;li&gt;이렇게 때문에 유니티 게임오브젝트를 회전시킬 때 사용하는 Rotate 함수는 유니티 내부에서 Quaternion으로 자동 변형되며, rotation은 Quaternion의 타입의 속성으로 Quaternion.Euler(x, y, z) 함수를 이용해 오일러 각을 Quaternion 타입으로 변형해서 대입해야 한다.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;-참-고-&quot;&gt;&lt;em&gt;&lt;strong&gt;[ 참 고 ]&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;
Quaternion.identity&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이것은 Quaternion 타입의 한 속성으로 API 문서에는 “회전 없음” 을 의미한다고 적혀있다.&lt;/li&gt;
  &lt;li&gt;추가로 월드 좌표 축 또는 부모의 축으로 정렬된다고 나와 있다.&lt;/li&gt;
  &lt;li&gt;하지만 이는 “회전 없음” 이라고 보기 보다는, “특정 회전 값 없이 생성하려는 프리팹 또는 3D 모델의 원래 회전각도로 적용한다” 라고 보는 것이 좀 더 정확할 것 같다.&lt;/li&gt;
  &lt;li&gt;API문서를 본다면 또 “쿼터니언은 복잡한 수를 기반으로 하고, 직관적으로 이해하기 쉽지 않습니다. 따라서 거의 접근하지 않거나 개별 쿼터니언 컴포넌트(x,y,z,w)를 수정하지 않습니다.” 라고 적혀있는데, 유니티는 다 배운 이후, Quaternion에 대해 좀 더 깊숙하게 공부해 볼 필요성이 있을 것 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고 : 유니티 API
https://docs.unity3d.com/kr/530/ScriptReference/Quaternion.html&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/23/about-quaternion.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/23/about-quaternion.html</guid>
        
        <category>Unity</category>
        
        <category>Quaternion</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Collider Component</title>
        <description>&lt;p&gt;&lt;br /&gt;
최종 수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;collider-component&quot;&gt;&lt;strong&gt;[Collider Component]&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;충돌을 감지하는 센서 역할을 하는 컴포넌트
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Box, Sphere, Capsule, Mesh, Wheel, Terrain 의 형태 Collider 제공
&lt;br /&gt;
    &lt;h2 id=&quot;box-collider&quot;&gt;&lt;em&gt;Box Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;가장 다용도로 사용.&lt;/li&gt;
  &lt;li&gt;Center, Size 속성으로 박스 형태를 조절
&lt;br /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/boxcollider.png&quot; alt=&quot;BoxCollider Component&quot; /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;sphere-collider&quot;&gt;&lt;em&gt;Sphere Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;가장 속도 처리가 빠른 Collider.&lt;/li&gt;
  &lt;li&gt;Radius 속성으로 구체의 반지름을 조절&lt;/li&gt;
  &lt;li&gt;정밀한 충돌 감지를 해야하는 경우를 제외하고서는 대부분 Sphere Collider 사용하는 것을 권장.
&lt;br /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/spherecollider.png&quot; alt=&quot;SphereCollider Component&quot; /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;capsule-collider&quot;&gt;&lt;em&gt;Capsule Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;주로 인체 또는 나무, 가로등과 같은 모델의 충돌체로 사용.&lt;/li&gt;
  &lt;li&gt;Height 속성으로 캡슐의 높이 조절 가능.&lt;/li&gt;
  &lt;li&gt;Direction 속성은 Height 값을 변경했을 때 커지는 축을 설정. 기본 Y축.
&lt;br /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/capsulecollider.png&quot; alt=&quot;CapsuleCollider Component&quot; /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;mesh-collider&quot;&gt;&lt;em&gt;Mesh Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;CPU 부하가 가장 높은 Collider&lt;/li&gt;
  &lt;li&gt;아주 세밀한 충돌 감지에 사용된다.&lt;/li&gt;
  &lt;li&gt;유니티에서는 Mesh Collider 간의 충돌 감지가 안되도록 기본값 설정.&lt;/li&gt;
  &lt;li&gt;속도 저하를 방지하기 위함&lt;/li&gt;
  &lt;li&gt;Convex 속성을 체크하면 Mesh 간의 충돌 감지 가능하나, 단순 메쉬로 변경.
&lt;br /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/meshcollider.png&quot; alt=&quot;MeshCollider Component&quot; /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;wheel-collider&quot;&gt;&lt;em&gt;Wheel Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;차량의 바퀴에 사용할 목적으로 제공.&lt;/li&gt;
  &lt;li&gt;바퀴의 서스펜션, 바닥과의 마찰저항과 미끄러지는 저항을 세밀하게 조절 가능.
&lt;br /&gt;
    &lt;h2 id=&quot;terrain-collider&quot;&gt;&lt;em&gt;Terrain Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;유니티에 내장된 Terrain Engine을 이용해 생성한 지형에 적용되는 Collider.&lt;/li&gt;
  &lt;li&gt;지형의 복잡도에 따라 Collider의 부하가 높아진다.&lt;/li&gt;
  &lt;li&gt;로우폴리 Mesh를 이용해 Mesh Collider로 대체하는 것도 좋은 방법.
&lt;br /&gt;
    &lt;h2 id=&quot;충돌-감지-조건&quot;&gt;&lt;em&gt;충돌 감지 조건&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;충돌을 일으키는 양쪽 게임오브젝트 모두 Collider 컴포넌트가 추가돼 있어야 한다.&lt;/li&gt;
  &lt;li&gt;두 게임오브젝트 중 움직이는 쪽에는 반드시 Rigidbody Component가 있어야한다.
&lt;br /&gt;
    &lt;h2 id=&quot;연산-처리-속도가-빠른-collider&quot;&gt;&lt;em&gt;연산 처리 속도가 빠른 Collider&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Sphere Collider &amp;gt; Capsule Collider &amp;gt; Box Collider
&lt;br /&gt;
    &lt;h2 id=&quot;충돌-이벤트&quot;&gt;&lt;em&gt;충돌 이벤트.&lt;/em&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Collider 컴포넌트를 포함한 게임오브젝트 간의 충돌이 발생할때 호출되는 이벤트.&lt;/li&gt;
  &lt;li&gt;모든 Collider Component에는 IsTrigger 속성이 있다.&lt;/li&gt;
  &lt;li&gt;이 속성을 체크할 경우 충돌은 감지되지만, 물리적인 충돌은 일어나지 않는다.&lt;/li&gt;
  &lt;li&gt;주로 감지 센서 역할을 하는 게임오브젝트에서 많이 사용하는 속성.
&lt;br /&gt;
    &lt;h3 id=&quot;void-oncollisionenter&quot;&gt;void OnCollisionEnter&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;IsTrigger UnCheck했을 시,&lt;/li&gt;
  &lt;li&gt;두 물체 간의 충돌이 일어나기 시작했을 때
 &lt;br /&gt;
    &lt;h3 id=&quot;void-oncollosionstay&quot;&gt;void OnCollosionStay&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;IsTrigger UnCheck했을 시,&lt;/li&gt;
  &lt;li&gt;두 물체 간의 충돌이 지속될 때
&lt;br /&gt;
    &lt;h3 id=&quot;void-oncollisionexit&quot;&gt;void OnCollisionExit&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;IsTrigger UnCheck했을 시,&lt;/li&gt;
  &lt;li&gt;두 물체가 서로 떨어졌을 때
&lt;br /&gt;
    &lt;h3 id=&quot;void-ontriggerenter&quot;&gt;void OnTriggerEnter&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;IsTrigger Check했을 시,&lt;/li&gt;
  &lt;li&gt;두 물체 간의 충돌이 일어나기 시작했을 때
&lt;br /&gt;
    &lt;h3 id=&quot;void-ontriggerstay&quot;&gt;void OnTriggerStay&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;IsTrigger Check했을 시,&lt;/li&gt;
  &lt;li&gt;두 물체 간의 충돌이 지속될 때
&lt;br /&gt;
    &lt;h3 id=&quot;void-ontriggerexit&quot;&gt;void OnTriggerExit&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;IsTrigger Check했을 시,&lt;/li&gt;
  &lt;li&gt;두 물체가 서로 떨어졌을 때&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
참고 자료&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;https://docs.unity3d.com/kr/2017.4/Manual/class-BoxCollider.html&lt;/li&gt;
  &lt;li&gt;https://docs.unity3d.com/kr/2017.4/Manual/class-SphereCollider.html&lt;/li&gt;
  &lt;li&gt;https://docs.unity3d.com/kr/2017.4/Manual/class-MeshCollider.html&lt;/li&gt;
  &lt;li&gt;https://docs.unity3d.com/kr/2017.4/Manual/class-CapsuleCollider.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 18 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/18/about-collider.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/18/about-collider.html</guid>
        
        <category>Unity</category>
        
        <category>component</category>
        
        <category>collider</category>
        
        <category>box collider</category>
        
        <category>capsule collider</category>
        
        <category>sphere collider</category>
        
        <category>mesh collider</category>
        
        <category>collision</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D RigidBody Component</title>
        <description>&lt;p&gt;&lt;br /&gt;
최종 수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;rigidbody-component&quot;&gt;&lt;strong&gt;[Rigidbody Component]&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GameObject가 물리 제어로 동작하게 하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;물리 시뮬레이션을 통해서 오브젝트의 위치를 조절.&lt;/li&gt;
  &lt;li&gt;중력, 충돌에 대한 오브젝트의 반응의 크기를 계산.
&lt;br /&gt;&lt;br /&gt;
    &lt;h2 id=&quot;property&quot;&gt;&lt;strong&gt;Property&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;Mass : 질량. 상대적인 의미의 질량으로, 일반적인 kg, g 등의 무게 단위는 아니다. ‘A 물체 mass가 1, B 물체 mass가 10이라고 할 때 B물체는 A물체보다 10배 더 무겁다.’ 라고 해석하는 것. 보통은 1Mass = 1Kg이라고 가정 후 작업하는 것이 일반적.
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Drag : 이동할 때 적용되는 마찰계수(저항)
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Angular Drag : 회전할 때 적용되는 마찰계수(저항)
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Use Gravity : 중력 적용 여부
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Is Kinematic : 체크하면(True) 물리엔진의 영향을 받지 않으며, Transform 컴포넌트를 이용해 이동한다.
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Interpolate : 물리력을 이용한 움직임이 끊어지는 현상이 발생할 때 보간해준다.
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Interpolate : 이전 프레임의 Transform에 맞게 처리
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Extrapolate : 다음 프레임의 Transform의 변화를 추정해 움직임을 처리
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Collision Detection : 세밀한 충돌을 검출하기 위한 옵션값
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Discrete -&amp;gt; Continuous -&amp;gt; Continuous Dynamic 순서로 정밀 검출
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Freeze Position : X,Y,Z 축 중에서 해당 축으로의 이동을 막는다.
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;Freeze Rotation : X,Y,Z 축 중에서 해당 축을 기준으로 한 회전을 막는다.
&lt;br /&gt;
&lt;img src=&quot;/static/assets/img/blog/Unity/rigidbody.png&quot; alt=&quot;이해를 돕기 위해 Rigidbody Component 이미지를 첨부&quot; /&gt;
&lt;br /&gt;
참고 : https://docs.unity3d.com/kr/530/ScriptReference/Rigidbody.html&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 17 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/17/about-rigidbody.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/17/about-rigidbody.html</guid>
        
        <category>Unity</category>
        
        <category>rigidbody</category>
        
        <category>리지드바디</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D GameObject</title>
        <description>&lt;p&gt;최종 수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;-gameobject&quot;&gt;&amp;gt; &lt;strong&gt;[GameObject]&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;유니티는 컴포넌트 기반 개발(CBD : Component Based Development) 방법론을 지원한다.&lt;/li&gt;
  &lt;li&gt;CBD는 독립적인 기능 단위로 컴포넌트를 제작해 필요한 기능을 조립하는 방식.&lt;/li&gt;
  &lt;li&gt;컴포넌트란 게임오브젝트의 기능을 담당하는 부분.&lt;/li&gt;
  &lt;li&gt;CBD는 컴포넌트의 재사용이 가능하고, 높은 생산성이 장점이다.&lt;/li&gt;
  &lt;li&gt;GameObject는 특정 속성이나 기능을 갖춘 오브젝트를 담을 수 있는 상자에 비유.&lt;/li&gt;
  &lt;li&gt;유니티에서는 일반적으로 사용되는 오브젝트를 일부 템플릿 형태로 제공&lt;/li&gt;
  &lt;li&gt;Light, 3D Object, Particle, Camera&lt;/li&gt;
  &lt;li&gt;캐릭터, 아이템, 상자, 몬스터 등 모든 것이 게임 오브젝트이다.&lt;/li&gt;
  &lt;li&gt;GameObject들은 기본적으로 Transform Component를 포함하고있다.&lt;/li&gt;
  &lt;li&gt;Transform Component를 통해 해당 Object가 월드 상에 어디에 위치하고 있는지, 얼마나 회전하고 있는지, 어느정도 크기인지 결정되기 때문.
&lt;br /&gt;
&lt;br /&gt;
    &lt;h2 id=&quot;유니티에서-gameobject에게-제공하는-기본함수&quot;&gt;&lt;strong&gt;유니티에서 GameObject에게 제공하는 기본함수&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;Awake&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;스크립트가 실행될 때 한 번만 호출되는 함수.&lt;/li&gt;
  &lt;li&gt;상태 값 또는 변수의 초기화에 사용된다.&lt;/li&gt;
  &lt;li&gt;스크립트 함수 중, 가장 먼저 호출된다.&lt;/li&gt;
  &lt;li&gt;스크립트가 비활성화 되어있어도 호출된다.&lt;/li&gt;
  &lt;li&gt;Coroutine으로 실행 불가.
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;Start&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Update 함수가 호출되기 이전에 한 번만 호출되는 함수.&lt;/li&gt;
  &lt;li&gt;스크립트가 활성화 되어있어야 실행된다.&lt;/li&gt;
  &lt;li&gt;다른 스크립트의 모든 Awake가 모두 다 실행된 이후에 실행된다.&lt;/li&gt;
  &lt;li&gt;Coroutine으로 실행 가능
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;Update&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;매 프레임마다 호출되는 함수.&lt;/li&gt;
  &lt;li&gt;주로 게임의 핵심 로직을 작성하는데 사용.&lt;/li&gt;
  &lt;li&gt;스크립트가 활성화 돼 있어야 실행된다.
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;LateUpdate
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 Update 함수가 호출되고 나서 한 번씩 호출된다.&lt;/li&gt;
  &lt;li&gt;Update 함수에서 전처리가 끝난 후 실행해야하는 로직에 사용된다.&lt;/li&gt;
  &lt;li&gt;카메라 이동 로직에 주로 사용하는 함수.&lt;/li&gt;
  &lt;li&gt;스크립트가 활성화 돼 있어야 실행된다.
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;FixedUpdate
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;물리엔진의 시뮬레이션 계산주기로 기본값은 0.02초다.&lt;/li&gt;
  &lt;li&gt;발생하는 주기가 일정하다.
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;OnEnable
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;게임 오브젝트 또는 스크립트가 활성화 됐을 때 호출된다.&lt;/li&gt;
  &lt;li&gt;이벤트 연결 시 사용한다.&lt;/li&gt;
  &lt;li&gt;Coroutine 사용 불가.
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;OnDisable
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;게임오브젝트 또는 스크립트가 비활성화 됐을 때 호출된다.&lt;/li&gt;
  &lt;li&gt;이벤트 연결을 종료할 때 사용한다.&lt;/li&gt;
  &lt;li&gt;Coroutine 사용 불가.
&lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;OnGUI
&lt;br /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;레거시 GUI 관련 함수를 사용할 때 사용한다.
&lt;br /&gt;
———————————————————————————-
&lt;br /&gt;
    &lt;h2 id=&quot;component-cache-처리&quot;&gt;&lt;strong&gt;Component Cache 처리&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Update는 프레임마다 한 번씩 호출되는 함수로서 항상 최적화에 주의를 기울여야 한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;이동 로직의 경우 Transform Component의 Position 속성을 조금씩 변경하는 것으로 프레임마다 Transform Component에 접근하는 방식은 바람직하지 않다.&lt;/li&gt;
  &lt;li&gt;따라서 Update 함수에서 접근해야 할 컴포넌트는 Awake 또는 Start 함수에서 미리 변수에 할당한 후에 Update 함수에서 사용하는 것을 권장한다.
&lt;br /&gt;
    &lt;h2 id=&quot;키워드&quot;&gt;&lt;strong&gt;키워드&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;h3 id=&quot;접근-지시자-public&quot;&gt;접근 지시자 public&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본적으로 다른 클래스에서 접근할 수 있게 해주는 접근 지시자.&lt;/li&gt;
  &lt;li&gt;유니티에서는 변수를 public으로 선언할 경우, Inspector View에 해당 변수가 노출되서, 변수의 값을 직접 수정할 수 있다.
&lt;br /&gt;
    &lt;h3 id=&quot;접근-지시자-private&quot;&gt;접근 지시자 private&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 클래스에서 접근할 수 없고, 해당 클래스에서만 사용할 수 있는 접근 지시자.&lt;/li&gt;
  &lt;li&gt;유니티에서는 Inspector View의 모드를 Debug Mode로 설정하면, private 변수값도 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;Debug Mode로 설정할 경우, Inspector View는 읽기 전용(Read-Only)가 된다.&lt;/li&gt;
  &lt;li&gt;Inspector View의 Default Mode는 Normal Mode.&lt;/li&gt;
  &lt;li&gt;또는 [SerializeField] 키워드를 해당 변수 private 앞에 선언할 경우, private 속성은 유지한 채, Inspector View에 해당 변수를 노출시킬 수 있다.
&lt;br /&gt;
    &lt;h3 id=&quot;this&quot;&gt;this&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;this 키워드를 사용한 해당 스크립트(클래스)를 지시.&lt;/li&gt;
  &lt;li&gt;this.gameObject&lt;/li&gt;
  &lt;li&gt;이 스크립트(클래스)가 추가된 게임오브젝트를 의미한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 17 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/17/about-gameobject.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/17/about-gameobject.html</guid>
        
        <category>Unity</category>
        
        <category>Awake</category>
        
        <category>component</category>
        
        <category>componentcache</category>
        
        <category>gameobject</category>
        
        <category>gamobject private</category>
        
        <category>public</category>
        
        <category>keyword</category>
        
        <category>기본함수</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unity3D Graphics, Light</title>
        <description>&lt;p&gt;최종 수정일 : 2018-08-13
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;graphics&quot;&gt;&lt;strong&gt;[Graphics]&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;texture&quot;&gt;&lt;strong&gt;Texture&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;3D 모델의 표면에 매핑시킬 이미지 파일을 지칭.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;h3 id=&quot;texture-기능으로-mesh-particle-및-interface에-이미지를-매핑&quot;&gt;Texture 기능으로 Mesh, Particle 및 Interface에 이미지를 매핑.&lt;/h3&gt;
  &lt;p&gt;&lt;br /&gt;
	- 매핑 - 이미지 또는 동영상을 오브젝트에 겹치거나 둘러싸는 것.
	- PSD(포토샵), PNG, JPEG, TIFF, GIF, BMP, TGA 등 다양한 이미지 파일 포맷  지원
	- PSD 파일에 있는 여러 개의 레이어를 자동으로 평면화(Flatten)한다.
	- 텍스쳐의 원본을 보존한 상태로 다양한 압축 포맷으로 용량을 줄이는 기능을 제공.
	- 텍스쳐의 크기가 가로세로 2^n 형태일 때 압축 지원 속도가 가장 빠르다.&lt;br /&gt;
    - 모바일 플랫폼을 사용할 경우 이 형태를 사용하는게 가장 유리하다.
&lt;br /&gt;&lt;/p&gt;
  &lt;h3 id=&quot;texture-type&quot;&gt;Texture Type&lt;/h3&gt;
  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Texture : 모든 텍스처에서 사용되는 가장 일반적인 설정.&lt;/li&gt;
    &lt;li&gt;Normal Map : 색상 채널을 실시간 노멀 매핑에 맞는 형식으로 변경.&lt;/li&gt;
    &lt;li&gt;Editor GUI : 텍스처가 임의의 HUD/GUI 컨트롤에서 사용된다면 사용 권장.&lt;/li&gt;
    &lt;li&gt;Sprite(2D and UI) : 텍스처가 2D게임에서 Sprite로 사용할 경우 권장.&lt;/li&gt;
    &lt;li&gt;Cubemap : 큐브 맵으로 알려져 텍스처의 반사를 만드는데 사용.&lt;/li&gt;
    &lt;li&gt;Cookie : 텍스처에서 라이팅의 쿠키에서 사용하는 기본 파라미터 설정.&lt;/li&gt;
    &lt;li&gt;Advanced : 텍스처에서 특정 파라미터를 이용해 세부적인 제어를 하고 싶을 경우 설정.
&lt;br /&gt;
      &lt;h3 id=&quot;material&quot;&gt;Material&lt;/h3&gt;
      &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;3D 모델에 적용할 텍스쳐의 다양한 속성을 설정하는 역할.&lt;/li&gt;
    &lt;li&gt;“어떤 텍스처를, 어떤 간격으로 반복하고, 표면의 재질은 어떻게 표현하느냐”
&lt;br /&gt;
      &lt;h3 id=&quot;mesh-filter&quot;&gt;Mesh Filter&lt;/h3&gt;
      &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;애니메이션이 적용되지 않은 3D모델은 Mesh Filter와 Mesh Renderer Component를 가지고 있다.&lt;/li&gt;
    &lt;li&gt;해당 모델의 3차원 형상 정보인 Mesh 데이터를 가지고 있는 컴포넌트.&lt;/li&gt;
    &lt;li&gt;Asset에서 Mesh 데이터를 가져와서 화면상에서 렌더링하기 위해 Mesh Renderer에 전달.&lt;/li&gt;
    &lt;li&gt;Scene 내의 Mesh를 확인하려면 Mesh Renderer를 게임 오브젝트에 추가하면 된다.&lt;/li&gt;
    &lt;li&gt;기본적으로 Mesh Filter Component를 게임 오브젝트에 추가할 경우 Mesh Renderer가 같이 추가 되지만, 임의로 삭제했을 경우 수동으로 다시 추가해줘야한다.&lt;/li&gt;
    &lt;li&gt;Mesh Renderer가 없는 경우에도 Mesh는 Scene(및 컴퓨터 메모리)에 존재하고 있지만, 그려지지는 않는다.
&lt;br /&gt;
      &lt;h3 id=&quot;mesh-renderer&quot;&gt;Mesh Renderer&lt;/h3&gt;
      &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;Mesh Filter가 가지고 있는 Mesh 데이터를 토대로 화면에 렌더링 처리를 하는 Component&lt;/li&gt;
    &lt;li&gt;유니티에서 제공하는 ~Renderer 계열의 컴포넌트는 반드시 Material 속성을 가지고 있기 때문에 텍스처 정보를 가지고 있는 머티리얼을 연결하는 속성이 있다는 것을 의미한다.
&lt;br /&gt;
      &lt;h3 id=&quot;shader&quot;&gt;Shader&lt;/h3&gt;
      &lt;p&gt;&lt;br /&gt;
Material에 적용한 텍스처를 렌더링할 때 표면의 재질감을 표현하는 방식을 결정한다.
&lt;br /&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;rendering-mode&quot;&gt;Rendering Mode&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Opaque : 기본값으로 불투명한 텍스처를 표현하는 옵션. 투명이 전혀 없는 Solid 객체에 적합.&lt;/li&gt;
  &lt;li&gt;Cutout : 불투명한 부분과 투명한 부분을 동시에 표현하는 옵션. 풀, 그물망 등을 표현할 때 적합.&lt;/li&gt;
  &lt;li&gt;Transparent : 투명한 플라스틱 또는 유리와 같이 재질을 표현하는 옵션.&lt;/li&gt;
  &lt;li&gt;Fade : 투명 속성값을 갖고 있는 객체를 페이드 아웃 시키는 옵션. 페이드 인/아웃을 애니메이션 처리할 수 있다. 홀로그램(Hologram) 효과 구현에 용이.&lt;/li&gt;
  &lt;li&gt;Albedo : 빛을 반사하는 정도. 반사율이라고 한다. 현실의 물체는 모두 각각 다른 빛 반사율을 가진다.&lt;/li&gt;
  &lt;li&gt;Metallic : 객체 표면에 금속의 재질을 표현하기 위한 텍스쳐. 슬라이드 값이 1에 가까워질수록 금속 재질에 가까워지는 특성.&lt;/li&gt;
  &lt;li&gt;Normal Map : 표면의 세밀한 입체감이나 질감을 표현하기 위한 텍스처의 일종으로 3D모델링으로 많은 폴리곤을 소모하지 않고 같은 효과를 낼 수 있다. 속성값이 
 커질수록 음영효과를 낸다.&lt;/li&gt;
  &lt;li&gt;Height Map : 텍스처로 높낮이를 표현하는 것. 노멀맵과 비슷하지만 사물을 더 돌출시켜 뒤에 있는 사물을 가리는 Occlusion 효과를 낼 수 있다.&lt;/li&gt;
  &lt;li&gt;Occlusion : 흑백의 텍스처로 간접조명에 의해 생기는 명암을 더욱 뚜렷이 표시해 사물의 입체감과 깊이감을 살리는 데 사용.&lt;/li&gt;
  &lt;li&gt;Emission : 스스로 빛을 방출하는 속성. 속성값을 변경하면 객체의 표면에서 방출되는 빛의 강도와 빛을 색상을 설정할 수 있는 항목이 나타남. 전역 조명에 반영하기 위한 옵션도 포함.&lt;/li&gt;
  &lt;li&gt;Detail Mask : Secondary Maps에 적용할 마스크를 설정하는 텍스처 슬롯. 특정 부분을 좀 더 세부적인 텍스쳐를 표현할 때 사용
&lt;br /&gt;
    &lt;h3 id=&quot;prefab&quot;&gt;Prefab&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;유니티에서 사용하는 Asset Type.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;컴포넌트 및 프로퍼티가 있는 게임 오브젝트를 저장할 수 있다.&lt;/li&gt;
  &lt;li&gt;자주 사용하는 객체를 미리 정의해놓은 GameObject 및 Component의 컬렉션을 재사용할 수 있게 하는 기능.&lt;/li&gt;
  &lt;li&gt;씬에서 새로운 오브젝트 인스턴스를 생성하는 템플릿으로 사용.&lt;/li&gt;
  &lt;li&gt;복사가 가능한 원본의 개념으로, 프리팹의 복사본(Clone)은 원본의 속성과 일치한다.&lt;/li&gt;
  &lt;li&gt;따라서 원본을 수정할 경우 그에 따라 복사본도 같이 수정된다.&lt;/li&gt;
  &lt;li&gt;각 인스턴스의 컴포넌트와 설정을 개별적으로 ‘오버라이드’ 할 수 있다.
&lt;br /&gt;
    &lt;h1 id=&quot;light&quot;&gt;&lt;strong&gt;[Light]&lt;/strong&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;h2 id=&quot;directional-light&quot;&gt;&lt;strong&gt;Directional Light&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;해당 라이트의 위치와 관계없이, 전체 화면에 균일한 빛을 비춘다.&lt;/li&gt;
  &lt;li&gt;다만, 빛을 비추는 각도에 따라 그림자의 방향과 길이가 달라진다.&lt;/li&gt;
  &lt;li&gt;실시간 그림자 지원
&lt;br /&gt;
    &lt;h2 id=&quot;point-light&quot;&gt;&lt;strong&gt;Point Light&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;백열전구와 같은 성격.&lt;/li&gt;
  &lt;li&gt;Point Light가 위치한 좌표를 중점으로 주변으로 퍼져나가는 조명.&lt;/li&gt;
  &lt;li&gt;빛의 범위를 설정할 수 있는 Range 속성이 있다.&lt;/li&gt;
  &lt;li&gt;실시간 그림자 지원
&lt;br /&gt;
    &lt;h2 id=&quot;spot-light&quot;&gt;&lt;strong&gt;Spot Light&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;손전등과 같이 Corn 모양으로 빛을 내는 조명/ 실시간 조명 중 가장 비싼 조명.&lt;/li&gt;
  &lt;li&gt;빛이 뻗어 나가는 각도를 조절할 수 있는 Spot Angle 속성이 있다.&lt;/li&gt;
  &lt;li&gt;실시간 그림자 지원
&lt;br /&gt;
    &lt;h2 id=&quot;area-light&quot;&gt;&lt;strong&gt;Area Light&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;사각형 형태의 조명으로 한쪽 면에서 빛을 발하는 조명.&lt;/li&gt;
  &lt;li&gt;라이트맵을 Bake해야만 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;유일하게 실시간 조명이 아니며 주로 간접 조명으로 사용.&lt;/li&gt;
  &lt;li&gt;실시간 그림자 미지원
 &lt;br /&gt;
    &lt;h2 id=&quot;shadow-type&quot;&gt;&lt;strong&gt;Shadow Type&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;No Shadows : 기본 설정값으로, 실시간 그림자를 적용하지 않는다.&lt;/li&gt;
  &lt;li&gt;Hard Shadows : 실시간 그림자를 표현하나 외곽선을 부드럽게 처리하지 않는다.&lt;/li&gt;
  &lt;li&gt;Soft Shadows : 부드러운 실시간 그림자를 표현하지만 가장 많은 부하를 준다.
&lt;br /&gt;
    &lt;h1 id=&quot;lod&quot;&gt;&lt;strong&gt;[LOD]&lt;/strong&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;h2 id=&quot;level-of-detail&quot;&gt;&lt;strong&gt;Level Of Detail&lt;/strong&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;화면을 렌더링하는 카메라로부터 멀리 떨어질수록 낮은 폴리곤으로 변경해서 렌더링 부하를 줄여주는 기법
&lt;br /&gt;&lt;/p&gt;
      &lt;h2 id=&quot;culled&quot;&gt;&lt;strong&gt;Culled&lt;/strong&gt;&lt;/h2&gt;
      &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;LOD 구간 중, 카메라로부터 너무 멀리 떨어져 있는 경우, 완전히 보이지 않게 하는 기법.&lt;/li&gt;
  &lt;li&gt;멀티플레이를 구현 할 때 메모리 활용할 때 유용하며, 모바일 게임의 최적화 기법 중 중요한 요소.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 16 Jul 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unity/2018/07/16/about-graphics.html</link>
        <guid isPermaLink="true">http://localhost:4000/unity/2018/07/16/about-graphics.html</guid>
        
        <category>Graphics</category>
        
        <category>Light</category>
        
        <category>Material</category>
        
        <category>Mesh</category>
        
        <category>Shader</category>
        
        <category>Texture</category>
        
        <category>Unity</category>
        
        <category>unity3d</category>
        
        
        <category>Unity</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Socket과 Weapon에 대해서..</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최종 업데이트 : 2018-04-10&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소켓과-총-붙이기&quot;&gt;소켓과 총 붙이기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;본에는 등이나 팔과 같이 특정 부위에 소켓을 붙일 수 있는데, 이 소켓에 총을 붙일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;작업-프로세스&quot;&gt;작업 프로세스&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐릭터 skeleton 클래스로 들어가서 원하는 부위의 스켈레톤에 소켓을 추가한다.&lt;/li&gt;
  &lt;li&gt;소켓에 프리뷰를 통해 총 에셋을 미리 구현시킨다.&lt;/li&gt;
  &lt;li&gt;몸과 총이 어색하지 않도록 각도를 조정한다.&lt;/li&gt;
  &lt;li&gt;캐릭터 블루프린트 클래스로 들어가서 Mesh가 Root가 되도록 static mesh를 새로 생성한다.&lt;/li&gt;
  &lt;li&gt;생성된 static mesh에 이름을 부여한 후, 소켓-&amp;gt;부모 소켓에 skeleton 클래스에서 선언했던 소켓을 추가한다.&lt;/li&gt;
  &lt;li&gt;static mesh에 원하는 총의 이미지를 집어넣는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;총-장착-및-조준-애니메이션&quot;&gt;총 장착 및 조준 애니메이션&lt;/h1&gt;

&lt;h2 id=&quot;작업-프로세스-1&quot;&gt;작업 프로세스&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 세팅 -&amp;gt; 입력 칸으로 가서 Action Mapping을 통해 입력받을 키와 행동 이름을 추가한다.&lt;/li&gt;
  &lt;li&gt;캐릭터 블루프린트로 들어가서 추가한 행동 이름에 대한 함수를 호출한다.&lt;/li&gt;
  &lt;li&gt;equip rifle -&amp;gt; 토글키&lt;/li&gt;
  &lt;li&gt;aiming -&amp;gt; 누르고 있을 때만 true, 떼면 false&lt;/li&gt;
  &lt;li&gt;언리얼 엔진 블루프린트에서 bool 값의 네모칸이 빈칸이면 false, 체크되있으면 true&lt;/li&gt;
  &lt;li&gt;bool형 변수를 선언하여 포즈를 블렌딩합니다.
    &lt;h2 id=&quot;set-static-mesh-함수---컴포넌트의-static-mesh를-노드의-공간에서-추가할-수-있는-함수&quot;&gt;Set static mesh 함수 -&amp;gt; 컴포넌트의 static mesh를 노드의 공간에서 추가할 수 있는 함수.&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;위젯-블루프린트-&quot;&gt;위젯 블루프린트 &lt;CrossHair 추가=&quot;&quot;&gt;&lt;/CrossHair&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;size to content : 원본 사이즈에 맞춰서 위젯의 크기를 조정해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;앵커 : 위젯의 위치를 잡아주는 툴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Alignment(정렬)&lt;/li&gt;
  &lt;li&gt;위젯의 피봇 위치.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽 위가 (0,0)이며, 오른쪽 아래가 (1,1)이다. 정렬 위치 조절을 통해 위젯 원점의 위치를 조절할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create Widget : 위젯을 생성하는 함수.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;get player controller : 0번째 인덱스는 무조건 내꺼(사용자).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Widget-&amp;gt;Add to Viewport : 뷰포트에 해당 위젯을 추가한다.(보이게 설정)&lt;/li&gt;
  &lt;li&gt;Widget-&amp;gt;Remove from Parent : 해당 위젯을 화면(Viewport)에서 삭제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fovfield-of-view-조정&quot;&gt;FOV(Field Of View) 조정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Camera -&amp;gt; Set Field Of View : 카메라의 뷰 각도를 업데이트할 수 있는 함수.&lt;/li&gt;
  &lt;li&gt;Timeline 함수 : 특정 시간동안 FOV 값을 애니메이션화 하여 업데이트 할 수 있게 도와주는 함수.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;피탄-이펙트&quot;&gt;피탄 이펙트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Ray Casting : 총알의 시작점과 끝점 사이에 존재하는 물체들을 검사한 후, 그 중 시작점에서 가장 가까운 물체를 리턴해준다.
 -&amp;gt; 언리얼 엔진에서는 Line Trace라고함.&lt;/li&gt;
  &lt;li&gt;기본적으로 FPS 게임에서는 LineTrace의 시작점은 총구의 끝이 아닌, CrossHair를 기준으로 간다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;언리얼의 기준에서 CrossHair를 기준으로 잡을 경우, 그 기준은 SpringArm이라고 보면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Get Control Location : 사용자의 위치를 리턴받는 함수.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get Forward Vector : 입력값을 벡터로 변환해주는 함수.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Complex Collision : 복합 컬리전. 폴리곤을 사용하여 표면을 정확하게 감싸는 컬리전.&lt;/li&gt;
  &lt;li&gt;Break Hit Result : LineTrace의 리턴값 중 하나로, 구조체의 변수값 하나하나 직접 접근하고 싶을 때 사용.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Impact Point : 맞은 장소 리턴.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Apply Damage : 액터에게 데미지를 넘겨줄 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnyDamage : Apply Damage 함수에서 피격된 액터(Damaged Actor)의 AnyDamage 이벤트가 호출됨.
이곳의 파라미터들은 앞쪽에서 줬던 Apply Damage 함수에서 선언한 파라미터들을 그대로 받아오는 것.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;화면의 카메라 정보는 Controller에 저장되어있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Apply POintDamage만 호출해도 AnyDamage도 같이 호출된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;랙돌ragdoll-세팅&quot;&gt;랙돌(Ragdoll) 세팅.&lt;/h2&gt;

&lt;h2 id=&quot;부분-랙돌ragdoll-세팅&quot;&gt;부분 랙돌(Ragdoll) 세팅.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Set All bodies below Simulate Physics&lt;/li&gt;
  &lt;li&gt;In Bone Name : 해당 액터의 Skeleton에 저장된 뼈 이름을 기준으로 컨트롤 하고 싶은 부분의 이름을 입력한다.&lt;/li&gt;
  &lt;li&gt;Set All bodies below Physics Blend Weight&lt;/li&gt;
  &lt;li&gt;Physics Blend Weight : 0~1사이의 값을 입력&lt;/li&gt;
  &lt;li&gt;값이 0인 경우, 애니메이션 포즈만 쓰겠다.&lt;/li&gt;
  &lt;li&gt;값이 1인 경우, 랙돌 계산 후 랙돌 포즈만 쓰겠다.&lt;/li&gt;
  &lt;li&gt;값이 0.5인 경우, 애니메이션 포즈 반, 랙돌 포즈 반씩 섞어 사용.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/08/add-weapon-process.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/08/add-weapon-process.html</guid>
        
        <category>Socket</category>
        
        <category>Weapon</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine LandScape에 대해서..</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최종 수정일 : 2018-04-18&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;랜드스케이프란&quot;&gt;랜드스케이프란?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;임의로 만들어진 모양의 그리드 3D 모델&lt;/li&gt;
  &lt;li&gt;X,Y 값 자동 계산(내가 건들수없음)&lt;/li&gt;
  &lt;li&gt;높이(Z) 값만 조각 기능을 통해서 제공&lt;/li&gt;
  &lt;li&gt;버텍스 사이의 길이는 100 -&amp;gt; Scale값, 단위는 cm&lt;/li&gt;
  &lt;li&gt;연두색으로 나뉘어 있는 큰 단위는 Section&lt;/li&gt;
  &lt;li&gt;Component는 Section의 모임&lt;/li&gt;
  &lt;li&gt;Number Of Component : 한 랜드스케이프에 들어가는 컴포넌트의 갯수&lt;/li&gt;
  &lt;li&gt;정리&lt;/li&gt;
  &lt;li&gt;한개의 랜드스케이프에 여러개의 컴포넌트가 들어가고,&lt;/li&gt;
  &lt;li&gt;한개의 컴포넌트에 여러개의 섹션이 포함되어있으며,&lt;/li&gt;
  &lt;li&gt;한개의 섹션은 여러개의 버텍스로 이루어진다.&lt;/li&gt;
  &lt;li&gt;랜드스케이프 하나당 최대 길이는 8.161Km&lt;/li&gt;
  &lt;li&gt;Section Per Component -&amp;gt; 한 컴포넌트에 몇개의 섹션을 지정할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;layer-info-object&quot;&gt;Layer Info Object&lt;/h2&gt;
&lt;p&gt;랜드스케이프 레이어에 대한 정보가 들어있는 에셋.
어느 지역에 얼마만큼의 강도로 텍스쳐를 칠할지의 강도&lt;/p&gt;

&lt;h2 id=&quot;lod란&quot;&gt;LOD란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Level Of Detail의 약자&lt;/li&gt;
  &lt;li&gt;플레이어를 기준으로 플레이어가 대상 스태틱 매쉬에 멀어지면 해당 매쉬를 덜 복잡한 버전 또는 보이지 않게끔 하여 레벨 퍼포먼스를 높이는 기술&lt;/li&gt;
  &lt;li&gt;.FBX로 저장된 매쉬로 구현.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;폴리지-시스템&quot;&gt;폴리지 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;랜드스케이프에서 텍스쳐링 하듯 스태틱 매쉬를 렌더링 할 수 있는 시스템&lt;/li&gt;
  &lt;li&gt;스태틱 매쉬들 간의 Z fighting이 일어나지 않게 조정&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;폴리지-타입&quot;&gt;폴리지 타입&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;align to normal -&amp;gt; 지형에 따라 폴리지를 어떻게 배치할 것인가?(나무는 꺼주고 잔디는 켜주는게 일반적)&lt;/li&gt;
  &lt;li&gt;Random Yaw -&amp;gt; 스태틱 매쉬가 바라보는 방향&lt;/li&gt;
  &lt;li&gt;Cull Distance -&amp;gt; 개활지의 경우 로딩을 어디까지(거리) 할 것인가?&lt;/li&gt;
  &lt;li&gt;컬리전 프리셋 -&amp;gt; 충돌 처리&lt;/li&gt;
  &lt;li&gt;LandScape Layers -&amp;gt; 특정 랜드스케이프에만 추가할 수 있게 하는 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로시저럴-함수&quot;&gt;프로시저럴 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단순한 절차적 생성 텍스처와 마스크를 빠프게 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;임포트된 텍스처에 비해 메모리가 절약된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Procedural Foliage Volume&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Procedural -&amp;gt; Collsion Radius : 나무들 간의 사이 거리&lt;/li&gt;
  &lt;li&gt;Procedural -&amp;gt; shade Radius : 일단 스킵&lt;/li&gt;
  &lt;li&gt;Procedural Foliage Blocking Volume -&amp;gt; 폴리지를 다시 시뮬레이션을 눌러도 폴리지 타입이 생성되는 것을 방지한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스트리밍-레벨&quot;&gt;스트리밍 레벨&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(작은 폴리지를 관리할 때 사용하는 것)퍼시스턴트 레벨의 자식 레벨, 퍼시스턴트가 살아있는 한, 메모리에 올렸다 내리는 것이 자연스러운 레벨&lt;/li&gt;
  &lt;li&gt;효율적인 메모리 관리가 가능&lt;/li&gt;
  &lt;li&gt;퍼시스턴트 레벨과 시공간을 공유.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;current-level현재-레벨&quot;&gt;Current Level(현재 레벨)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;액터를 추가할 때, 액터가 추가되는 맵의 레벨&lt;/li&gt;
  &lt;li&gt;레벨 창에서 파란색으로 이름이 표시되있는 것이 현재 레벨&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;level-bounds레벨-바운드&quot;&gt;Level Bounds(레벨 바운드)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스트리밍 레벨이 퍼시스턴트 레벨에서 어느정도 범위를 가지고 있는지 미리 계산을 해서 박스의 형태로 가지고 있는 것&lt;/li&gt;
  &lt;li&gt;폴리지는 액터 취급을 안해줌&lt;/li&gt;
  &lt;li&gt;레벨 바운드의 범위(streaming distance)를 직접 지정해주고 싶을 경우 레벨 탭의 월드 컴포지션으로 들어감.&lt;/li&gt;
  &lt;li&gt;하나의 레벨 바운드는 하나의 레이어만 할당할 수 있다.(1:1 관계)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;world-composition월드-컴포지션&quot;&gt;World Composition(월드 컴포지션)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스트리밍 레벨이 어떻게 나뉘어있는지 한눈에 볼 수 있는 툴&lt;/li&gt;
  &lt;li&gt;레이어를 새로 생성해서 커스텀할 경우 스트리밍 거리를 커스텀 할 수 있다.&lt;/li&gt;
  &lt;li&gt;레이어는 수정 기능이 없음.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;하나도 세팅되지 못한 레이어는 나중에 자동적으로 삭제됨.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[참조]언리얼엔진이 아닌, 맵을 구성할 때 사용하면 유용한 이미지 툴&lt;/li&gt;
  &lt;li&gt;월드 머신 / 월드 크리에이터 (유료 버전만 존재)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Wysilab - Instant Terra : 무료 트라이얼&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Height Map : 버텍스 하나를 그림파일로 대응시키는 방식&lt;/li&gt;
  &lt;li&gt;흰색 : 최고 높은 지형의 색&lt;/li&gt;
  &lt;li&gt;검은색 : 최고 낮은 지형의 색&lt;/li&gt;
  &lt;li&gt;Height가 0~255 일 때, Import하면 -256&lt;em&gt;(Scale Z축의 값)~256&lt;/em&gt;(Scale Z축의 값)으로 임포트됨&lt;/li&gt;
  &lt;li&gt;Scale = Instant Terra Range값 / 512(언리얼엔진 값 범위 [상수])
// FOB&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 08 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/08/about-land-scape.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/08/about-land-scape.html</guid>
        
        <category>Actor</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Possess에 대해서..</title>
        <description>&lt;h1 id=&quot;possess-&quot;&gt;Possess &lt;빙의&gt;&lt;/빙의&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;맵 상에 존재하는 Pawn을 지목하여 플레이어 컨트롤러가 처리하지 않는 키를 Pawn에게 전달하는 행위&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mesh--캐릭터의-겉모습을-표현해주는-버텍스&quot;&gt;mesh = 캐릭터의 겉모습을 표현해주는 버텍스,&lt;/h2&gt;
&lt;h2 id=&quot;animation-data--캐릭터의-애니메이션을-표현해주는-데이터&quot;&gt;animation data = 캐릭터의 애니메이션을 표현해주는 데이터&lt;/h2&gt;
&lt;h2 id=&quot;fbs-file---unreal-import&quot;&gt;fbs file -&amp;gt; unreal import&lt;/h2&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/05/about-possess.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/05/about-possess.html</guid>
        
        <category>Possess</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine System에 대해서..</title>
        <description>&lt;h1 id=&quot;unreal-engine-4-game-system&quot;&gt;Unreal Engine 4 Game System.&lt;/h1&gt;

&lt;h2 id=&quot;game-mode&quot;&gt;Game Mode&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;게임에 영향을 미치는 가장 중요한 규칙을 구현하는 액터&lt;/li&gt;
  &lt;li&gt;게임 서버의 역할을 한다고 봄.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hud--게임-ui를-렌더링하는-액터&quot;&gt;HUD : 게임 UI를 렌더링하는 액터&lt;/h3&gt;

&lt;h3 id=&quot;playerstate--남들이-알아야-하는-내-정보를-저장하는-액터&quot;&gt;PlayerState : 남들이 알아야 하는 내 정보를 저장하는 액터&lt;/h3&gt;

&lt;h3 id=&quot;gamestate--게임에-공통된-정보를-동기화-시킬-때-저장하는-장소로-사용하는-액터&quot;&gt;GameState : 게임에 공통된 정보를 동기화 시킬 때 저장하는 장소로 사용하는 액터&lt;/h3&gt;

&lt;p&gt;// 참고 .. 데디케이트 서버 : 클라이언트가 없고 게임 로직만 돌아가는 서버&lt;/p&gt;

&lt;p&gt;// 맵 이동을 하게 되면, 게임 모드와 플레이어 컨트롤러가 날라간다(삭제 후 재호출).
// 게임 스테이트, 플레이어 스테이트, 폰 모두 날라감&lt;/p&gt;

&lt;h2 id=&quot;레벨간의-데이터를-주고-받을-수-있는-방법&quot;&gt;레벨간의 데이터를 주고 받을 수 있는 방법&lt;/h2&gt;

&lt;h3 id=&quot;game-instance-class--게임이-처음-실행-될-때-생성된-후-게임이-종료될-때-destroy&quot;&gt;Game Instance Class : 게임이 처음 실행 될 때 생성된 후, 게임이 종료될 때 destroy&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;project setting -&amp;gt; map &amp;amp; mod -&amp;gt; game default map : 게임 실행 파일을 실행했을 때 제일 처음 실행될 맵(보통 인트로 or 로그인)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/05/about-engine-system.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/05/about-engine-system.html</guid>
        
        <category>System</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Character에 대해서..</title>
        <description>&lt;h1 id=&quot;character-&quot;&gt;Character &lt;캐릭터&gt;&lt;/캐릭터&gt;&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Skeletal mesh - Bone이 있는 mesh&lt;/li&gt;
  &lt;li&gt;스태틱매쉬 : Bone이 없는 mesh » skeletal mesh옵션 off&lt;/li&gt;
  &lt;li&gt;import mesh - 버텍스와 폴리곤 정보를 임포트 할 것인가? -&amp;gt;off 할 경우에는 애니메이션만 가져오겠다는 표현.&lt;/li&gt;
  &lt;li&gt;import Material : 보통은 off 시킴&lt;/li&gt;
  &lt;li&gt;import texture : 보통 off 시킴&lt;/li&gt;
  &lt;li&gt;PhysicsAsset : 본마다 컬리젼을 만들어준 것&lt;/li&gt;
  &lt;li&gt;Skeletal Mesh : 캐릭터의 버텍스, 폴리곤 정보&lt;/li&gt;
  &lt;li&gt;Skeleton : 캐릭터의 뼈 구조를 확인 할 수 있는 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;capsulecomponent--root-component--캐릭터의-충돌-처리나-이동은-캡슐-컴포넌트를-활용&quot;&gt;CapsuleComponent : Root Component / 캐릭터의 충돌 처리나 이동은 캡슐 컴포넌트를 활용&lt;/h2&gt;
&lt;h2 id=&quot;arrow-component--캐릭터의-진행방향을-나타내주는-방향&quot;&gt;Arrow Component : 캐릭터의 진행방향을 나타내주는 방향&lt;/h2&gt;
&lt;h2 id=&quot;mesh--스캘레탈-매쉬-컴포넌트--이거-외에도-원한다면-스켈레탈-매쉬를-추가할-수-있음&quot;&gt;Mesh : 스캘레탈 매쉬 컴포넌트 / 이거 외에도 원한다면 스켈레탈 매쉬를 추가할 수 있음.&lt;/h2&gt;
&lt;p&gt;// 줄 : Scene Component와 Actor Component를 구분짓는 선&lt;/p&gt;

&lt;h2 id=&quot;character-movement--캐릭터-이동에-관련된-기능들이-들어있음-네트워킹-기능이-구현이-되어있음-멀티플레이어-시-캐릭터-이동을-부드럽게-보간해주는-기능이-들어있음-오직-캐릭터-클래스에만-들어가있음--게이머가-바라보고-있는-방향에-영향을-받음&quot;&gt;Character Movement : 캐릭터 이동에 관련된 기능들이 들어있음. 네트워킹 기능이 구현이 되어있음. 멀티플레이어 시 캐릭터 이동을 부드럽게 보간해주는 기능이 들어있음. 오직 캐릭터 클래스에만 들어가있음. / 게이머가 바라보고 있는 방향에 영향을 받음.&lt;/h2&gt;

&lt;p&gt;//마우스 입력값을 받았을 때 플레이어 컨트롤러에 입력값을 저장.&lt;/p&gt;

&lt;h2 id=&quot;add-controller-yaw-input--pawn의-플레이어-컨트롤러를-찾아서-x회전값을-누적시켜서-카메라의-절대-회전값을-변환-시켜준다&quot;&gt;add controller yaw input : pawn의 플레이어 컨트롤러를 찾아서, x회전값을 누적시켜서 카메라의 절대 회전값을 변환 시켜준다.&lt;/h2&gt;
&lt;h2 id=&quot;add-controller-pitch-input--pawn의-플레이어-컨트롤러를-찾아서-y회전값을-누적시켜서-카메라의-절대-회전값을-변환-시켜준다&quot;&gt;add controller pitch input : pawn의 플레이어 컨트롤러를 찾아서, y회전값을 누적시켜서 카메라의 절대 회전값을 변환 시켜준다.&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;둘 다 카메라를 직접 회전시켜주는 것은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;springarm--use-pawn-control-rotation--플레이어-컨트롤러에-로테이션을-사용하겠다&quot;&gt;SpringArm : Use pawn control Rotation : 플레이어 컨트롤러에 로테이션을 사용하겠다.&lt;/h2&gt;
&lt;h2 id=&quot;inherit-roll--카메라가-마치-롤러-코스터처럼-회전하는-방식&quot;&gt;Inherit Roll : 카메라가 마치 롤러 코스터처럼 회전하는 방식.&lt;/h2&gt;

&lt;h2 id=&quot;axis-가상키--키의-입력이-없어도-매-프레임마다-호출이-된다&quot;&gt;axis 가상키 : 키의 입력이 없어도 매 프레임마다 호출이 된다.&lt;/h2&gt;

&lt;h2 id=&quot;add-input-vector--캐릭터가-어느방향으로-이동하고-싶은지-방향을-알려주는-함수-방향은-월드-축을-기준으로-알려줌&quot;&gt;add input vector : 캐릭터가 어느방향으로 이동하고 싶은지 방향을 알려주는 함수. 방향은 월드 축을 기준으로 알려줌.&lt;/h2&gt;
&lt;h2 id=&quot;get-control-rotation--컨트롤러의-로테이션을-가져오는-함수&quot;&gt;Get Control Rotation : 컨트롤러의 로테이션을 가져오는 함수&lt;/h2&gt;
&lt;h2 id=&quot;get-forward-vector--내가-바라보고-있는-방향을-벡터로-변환&quot;&gt;Get Forward Vector : 내가 바라보고 있는 방향을 벡터로 변환&lt;/h2&gt;
&lt;h2 id=&quot;상수--벡터--부호를-곱해줘서-앞인지-뒤인지-확인&quot;&gt;상수 * 벡터 : 부호를 곱해줘서 앞인지 뒤인지 확인.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Yaw, Pitch, Roll에 대해 외우는 소소한 팁…&lt;/li&gt;
  &lt;li&gt;Yaw : Yaw리조리 두리번두리번&lt;/li&gt;
  &lt;li&gt;Pitch : 끄덕끄덕(피.. 알았어)&lt;/li&gt;
  &lt;li&gt;Roll : 롤러코스터 전방 360도 회전&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;한-프레임-내에-add-input-vector가-여러번-호출되도-character-movement에서-한번에-취합해서-처리한-후-최종-월드-vector에-대해-처리하기-때문에-상관없음&quot;&gt;한 프레임 내에 Add Input Vector가 여러번 호출되도 Character Movement에서 한번에 취합해서 처리한 후 최종 월드 Vector에 대해 처리하기 때문에 상관없음.&lt;/h2&gt;

&lt;h2 id=&quot;animation-sequence--반복되는-하나의-동작&quot;&gt;Animation Sequence : 반복되는 하나의 동작&lt;/h2&gt;
&lt;h2 id=&quot;animation-blueprint&quot;&gt;Animation BluePrint&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;try get pawn owner : 이 블루프린트를 쓰고 있는 pawn을 가져올 수 있다.&lt;/li&gt;
  &lt;li&gt;다른 쓰레드에서 돌기때문에 변수를 공유해서 쓸수 없으므로, 새로 변수를 선언해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;blend-space-1d--변수-하나의-값에-따라서-어떤-시퀀스를-실행을-해줄지-선택해주는-에셋&quot;&gt;Blend space 1D : 변수 하나의 값에 따라서 어떤 시퀀스를 실행을 해줄지 선택해주는 에셋.&lt;/h2&gt;

&lt;h2 id=&quot;state-machine--상태기계-안에-여러가지-state행동이-존재&quot;&gt;State Machine : 상태기계 안에 여러가지 State(행동)이 존재&lt;/h2&gt;

&lt;h2 id=&quot;animation-blueprint-bond-transform-rotation-rotation-mode&quot;&gt;Animation BluePrint-&amp;gt;Bond Transform-&amp;gt;Rotation-&amp;gt;Rotation Mode&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Replace Existing : 기존 회전값 무시&lt;/li&gt;
  &lt;li&gt;Add to Existing : 기존 회전값 +@&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;중첩된-상태기계&quot;&gt;중첩된 상태기계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;많은 애니메이션을 표현할 때 bool로 포즈를 블렌딩 하는 함수보다 효율적.&lt;/li&gt;
  &lt;li&gt;가장 큰 상태를 먼저 정의한 후,&lt;/li&gt;
  &lt;li&gt;각각의 상태에 들어가서 또 다시 작은 상태를 정의&lt;/li&gt;
  &lt;li&gt;그 안에서 분기에 따른 애니메이션을 부여한다.&lt;/li&gt;
  &lt;li&gt;처음엔 어려울 수 있으나, 적응되면 나중에 많은 애니메이션을 관리할 때 더욱 수월하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;notify&quot;&gt;Notify&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션이나 시퀀스가 진행이 될 때 특정 타이밍에 애니메이션 블루프린트에게 이벤트를 던져 줄 수 있다.&lt;/li&gt;
  &lt;li&gt;역으로 애니메이션 블루프린트가 Pawn에게도 알려줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;점프&quot;&gt;점프&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐릭터가 땅에 닿았는지 떨어져있는지는 CapsuleComponent를 기준으로 확인&lt;/li&gt;
  &lt;li&gt;isFalling 함수도 CapsuleComponent를 기준으로 삼음. (땅에 떨어져 있으면 true, 붙어있으면 false)&lt;/li&gt;
  &lt;li&gt;isFalling은 애니메이션 무브먼트에서도 접근이 가능하기 때문에 따로 변수로 승격시키지 않아도 됨.&lt;/li&gt;
  &lt;li&gt;애님몽타쥬의 애니메이션 슬롯을 어떤 것을 사용할 지 정하는 곳은 ‘애님몽타쥬’에 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/05/about-character.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/05/about-character.html</guid>
        
        <category>Character</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Animation</title>
        <description>&lt;h4 id=&quot;최종-수정-2020-05-01&quot;&gt;최종 수정 (2020-05-01)&lt;/h4&gt;

&lt;h1 id=&quot;애니메이션&quot;&gt;애니메이션&lt;/h1&gt;

&lt;h2 id=&quot;애니메이션-블루프린트&quot;&gt;애니메이션 블루프린트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐릭터가 다양한 상황에 적절한 애니메이션을 체계적으로 재생하도록 도와주는 애니메이션 시스템 제작 도구&lt;/li&gt;
  &lt;li&gt;애님 그래프(Anim Graph)와 애님 인스턴스(Anim Instance)로 구성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;애님-인스턴스&quot;&gt;애님 인스턴스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시각적 도구를 사용해 애니메이션 시스템을 제작하도록 설계&lt;/li&gt;
  &lt;li&gt;스켈레탈 메시를 소유하는 폰의 정보를 받아 애님 그래프가 참조할 데이터를 제공.&lt;/li&gt;
  &lt;li&gt;블루프린트와 C++로 제작 가능&lt;/li&gt;
  &lt;li&gt;틱마다 호출되는 NativeAnimationUpdate 가상함수 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;애님-그래프&quot;&gt;애님 그래프&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션 블루프린트의 기반을 이룸.&lt;/li&gt;
  &lt;li&gt;애님 인스턴스의 변수 값에 따라 변화하는 애니메이션 시스템을 설계하는 공간.&lt;/li&gt;
  &lt;li&gt;블루프린트로만 제작 가능&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스테이트 머신(State Machine 제공)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;스테이트 머신(State Machine)&lt;/li&gt;
  &lt;li&gt;유한 상태 기계(FSM)&lt;/li&gt;
  &lt;li&gt;기계가 반복 수행해야 하는 동작을 설계한 단위인 스테이트(State)를 정의하는 것으로 시작.&lt;/li&gt;
  &lt;li&gt;스테이트 머신은 여러개의 스테이트를 설계할 수 있는데, 그 중 하나의 스테이트만 지정해 해당 스테이트에서 지정한 동작을 반복수행한다.&lt;/li&gt;
  &lt;li&gt;애니메이션 시스템에서는 캐릭터가 반복해서 재생해야 할 애니메이션 동작을 의미함.&lt;/li&gt;
  &lt;li&gt;하나의 스테이트에서 다른 스테이트로 이동하기 위한 조건이 필요한데, 이를 트랜지션(Transition)이라고 한다.&lt;/li&gt;
  &lt;li&gt;시작지점인 Entry와 연결된 스테이트를 특별히 ‘시작 스테이트’라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;애니메이션-리타겟&quot;&gt;애니메이션 리타겟&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;언리얼에서 제공하는 기능으로, 인간형 캐릭터의 경우 스켈레톤의 구성이 달라도 애니메이션을 교환할 수 있도록 제공하는 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;애니메이션-몽타주&quot;&gt;애니메이션 몽타주&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Asset의 일종&lt;/li&gt;
  &lt;li&gt;몽타주란, 촬영된 화면이나 인쇄된 종이를 떼어 붙여서 새로운 장면이나 이미지를 만드는 미술 기법을 의미한다.&lt;/li&gt;
  &lt;li&gt;여러 애니메이션 클립들의 일부를 떼어내고 붙여서 새로운 애니메이션을 생성하는 기법(여러개의 시퀀스를 합쳐서 재생시켜주는 기능)&lt;/li&gt;
  &lt;li&gt;스테이트 머신의 확장 없이 특정 상황에서 원하는 애니메이션을 발동시킬 수 있는 기능.&lt;/li&gt;
  &lt;li&gt;시작, 루프, 끝 애니메이션을 나눠서 섹션 구간별 이벤트를 발생시킬 수 있는 섹션 기능&lt;/li&gt;
  &lt;li&gt;몽타주는 섹션(Section)을 단위로 애니메이션을 관리한다.&lt;/li&gt;
  &lt;li&gt;애니메이션 몽타주가 실행되기 이전의 애니메이션 포즈들을 모두 삭제 후, 애니메이션 몽타주에 저장되있는 애니메이션들을 사용한다.&lt;/li&gt;
  &lt;li&gt;일정 타이밍에 소리를 출력하거나, 이펙트를 출력하는 등, 시점을 잡을 수 있다.&lt;/li&gt;
  &lt;li&gt;커스텀 커브 기능&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pawn이 애니메이션 블루프린트한테 바로 명령을 내릴 수 있다&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스 : 애니메이션 몽타주 생성 -&amp;gt; 스켈레톤 선택 -&amp;gt; 몽타쥬에 원하는 애니메이션을 정의 후, 캐릭터 블루프린트에서 해당 이벤트가 발생했을 경우 skeletal mesh를 통해서 애니메이션 블루프린트를 가져와서 montage play 함수를 호출한다. -&amp;gt; 애니메이션 블루프린트로 가서 애니메이션 컴포넌트를 최종 애니메이션 포즈로 입력하는 사이에 Montage의 DefaultSlot을 통과하게 중간에 배치한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;### 몽타주 Tick Type&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Branching Point : 해당 프레임에 즉각적으로 반응하는 방식. 섹션을 바꾸거나 몽타주 위치 변경을 원할 경우에 적합합니다.&lt;/li&gt;
  &lt;li&gt;Queued : 비동기 방식으로 신호를 받는 방식. 타이밍에 민감하지 않은 사운드나 이펙트를 발생시킬 때 사용하는 것이 적합합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;애니메이션-노티파이&quot;&gt;애니메이션 노티파이&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션을 재생하는 동안 특정 타이밍에 애님 인스턴스에게 신호를 보내는 기능이다.&lt;/li&gt;
  &lt;li&gt;애니메이션 블루프린트의 노티파이 섹션에서 우클릭 후 노티파이 추가를 하면 원하는 시점에 애님 인스턴스에게 알림을 보낼 수 있는 노티파이가 추가된다.&lt;/li&gt;
  &lt;li&gt;노티파이가 호출되면 엔젠에서 애님 인스턴스 클래스 내부의 ‘AnimNotify_노티파이명’ 으로 작성된 멤버함수를 찾아서 호출한다.&lt;/li&gt;
  &lt;li&gt;이 때, 해당 멤버 함수는 반드시 UFUNCTION 매크로가 지정되어 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;함수&quot;&gt;함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Skeletal Mesh -&amp;gt; Get Anim Instance : 스켈레탈 매쉬에 있는 애니메이션 블루프린트를 가져온다.&lt;/li&gt;
  &lt;li&gt;Get Anim Instance -&amp;gt; Montage Play : 생성해놓은 애니메이션 몽타주를 실행한다.&lt;/li&gt;
  &lt;li&gt;Montage_IsPlaying : 현재 몽타주가 재생되고 있는지 파악 (리턴값 bool)&lt;/li&gt;
  &lt;li&gt;본 마다 레이어로 블렌딩 -&amp;gt; Mesh Space Rotation : 본의 좌표 기준으로 할 것인지, 컴포넌트 스페이스 기준으로 할 것인지 정하는 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;델리게이트&quot;&gt;델리게이트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 객체가 해야 할 로직을 다른 객체가 대신 처리할 수 있도록 만드는 보편적인 설계의 개념을 의미한다.&lt;/li&gt;
  &lt;li&gt;언리얼에서 델리게이트는 C++ 객체에서만 사용할 수 있는 델리게이트와 C++와 블루프린트 객체가 모두 사용할 수 있는 델리게이트로 나뉜다.&lt;/li&gt;
  &lt;li&gt;블루프린트 오브젝트는 멤버 함수에 대한 정보를 저장하고 로딩하는 직렬화(Serialization) 매커니즘이 들어있기 때문에 일반 C++ 언어가 관리하는 방법으로 멤버 함수를 관리할 수 없다.&lt;/li&gt;
  &lt;li&gt;그렇기 떄문에 블루프린트와 관련된 C++ 함수는 모두 UFUNCTION 매크로를 사용해야 한다.&lt;/li&gt;
  &lt;li&gt;이렇게 블루프린트 객체와도 연동하는 델리게이트를 언리얼 엔진에서는 다이나믹 델리게이트(Dynamic Delegate) 라고 한다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진에서 델리게이트의 선언은 언리얼이 제공하는 매크로를 통해 정의되며, 이를 시그니처(Signature)라고 한다.&lt;/li&gt;
  &lt;li&gt;델리게이트를 통해 이용 객체가 어떤 것인지 몰라도 델리게이트에 연결된 함수만 호출하면 되므로, 의존성 없는 설계를 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;멀티캐스트-델리게이트&quot;&gt;멀티캐스트 델리게이트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;등록 되어 있는 모든 함수에게 알려주는 기능을 하는 델리게이트.(Broadcast)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/05/about-animation.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/05/about-animation.html</guid>
        
        <category>Animation</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Unreal Engine Actor</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최종 수정일 : 2020-04-26&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;월드&quot;&gt;월드&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;월드는 언리얼에서 제공하는 한 프로젝트의 구성 공간을 의미하며, 게임에서 흔히 말하는 맵을 표현.&lt;/li&gt;
  &lt;li&gt;월드는 프로젝트당 한개만 존재한다.&lt;/li&gt;
  &lt;li&gt;월드에는 캐릭터, 몬스터, 배경 등 수많은 오브젝트들이 존재하는데, 이것들을 전부 액터라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;레벨--게임에서의-맵을-표현하는-언리얼엔진의-단위&quot;&gt;레벨 : 게임에서의 맵을 표현하는 언리얼엔진의 단위&lt;/h2&gt;
&lt;h2 id=&quot;스폰--월드또는-레벨에-액터를-실시간으로-추가하는-행위--월드-상에-액터-클래스를-전달받아서-액터-클래스에-맞는-새로운-오브젝트를-만드는-행위&quot;&gt;스폰 : 월드(또는 레벨)에 액터를 실시간으로 추가하는 행위 / 월드 상에 액터 클래스를 전달받아서 액터 클래스에 맞는 새로운 오브젝트를 만드는 행위&lt;/h2&gt;

&lt;h1 id=&quot;액터--콘텐츠를-구성하는-최소단위의-물체&quot;&gt;액터 : 콘텐츠를 구성하는 최소단위의 물체&lt;/h1&gt;
&lt;p&gt;*월드(레벨)를 꾸며주는 모든 컴포넌트 또는 리플리케이션의 단위&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리플리케이션(Replication) : 네트워크 게임에서 서로 동기화하는 작업&lt;/li&gt;
  &lt;li&gt;그러므로 액터의 직렬화를 통해서 네트워크 데이터 동기화의 기능을 가지고 있다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진은 모든 단위를 액터로 통제한다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진을 사용함에 있어 가장 중요한 클래스.&lt;/li&gt;
  &lt;li&gt;모든 액터가 물체 또는 형태를 가지고 있는 것은 아니다.(ex. Player Controller, Game Mode)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기초적인-액터-개념에-대해서-살펴보자&quot;&gt;기초적인 액터 개념에 대해서 살펴보자&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;액터 클래스&lt;/li&gt;
  &lt;li&gt;레벨에 배치되거나 스폰 될 수 있는 객체의 기본 클래스.&lt;/li&gt;
  &lt;li&gt;액터 내부에는 액터의 이동 방법, 렌더링 방법 등을 제어하는 데 사용할 수 있는 ActorComponents Collections가 포함되어 있다.&lt;/li&gt;
  &lt;li&gt;컨텐츠 브라우저에서 우리가 원하는 커스텀 액터 클래스를 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;개별적인 에셋으로 존재하거나 엔진에 내장되어 있다.&lt;/li&gt;
  &lt;li&gt;플레이 중 네트워크에서 속성 및 기능 함수 호출을 복제하는 기능도 포함되어 있다.&lt;/li&gt;
  &lt;li&gt;액터는 기능을 담당하는 컴포넌트들을 담아서 사용하는 그릇이라고 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;레벨 안에서의 최소 커뮤니케이션 단위는 액터 안에서의 상호작용으로 일어난다.&lt;/li&gt;
  &lt;li&gt;클래스이기 때문에 함수와 변수를 소유할 수 있다.&lt;/li&gt;
  &lt;li&gt;구체적인 개별 에셋들을 만들 때는 액터에 그에 맞는 컴포넌트를 추가한 후 에셋을 추가해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;액터의-구성-요소&quot;&gt;액터의 구성 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이름 : 작업을 위해 액터에 부여된 명칭. 여러 액터가 같은 이름을 가질 수 있다.&lt;/li&gt;
  &lt;li&gt;유형 : 게임플레이에서 수행할 액터의 역할을 의미한다. 프로그래밍 관점에서는 액터의 클래스 이름이다.&lt;/li&gt;
  &lt;li&gt;트랜스폼 : 액터는 반드시 월드에 존재해야 하므로, 액터에는 항상 트랜스폼이 부여된다.&lt;/li&gt;
  &lt;li&gt;프로퍼티 : 액터에 설정된 속성값. 디테일 윈도우에서 편집해 같은 유형을 가진 액터가 서로 다른 일을 하게 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;게임 로직 : 액터에 특정 상황이 발생할 때 이에 대응할 구체적인 행동을 명령하는 로직. 언리얼 엔진은 블루프린트와 C++라는 두 가지 언어를 지원한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;액터 오브젝트&lt;/li&gt;
  &lt;li&gt;액터 클래스를 월드에 생성한 인스턴스를 지칭함.&lt;/li&gt;
  &lt;li&gt;액터 오브젝트는 월드 아웃라이너 탭에서 생성됬는지 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;액터 오브젝트는 Level Asset에 나열되서 저장된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;스폰 Spawn&lt;/li&gt;
  &lt;li&gt;액터를 월드(레벨)에 생성하는 행위&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;액터 클래스를 월드에 인스턴스를 생성하는 것을 의미함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;블루프린트 클래스&lt;/li&gt;
  &lt;li&gt;부모 클래스 : 선택한 클래스를 상속받는 액터 클래스를 만든다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부모 클래스의 최상위 클래스는 액터 클래스이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pawn&lt;/li&gt;
  &lt;li&gt;액터를 상속 받아서 만든 클래스&lt;/li&gt;
  &lt;li&gt;플레이어나 AI가 제어할 수 있는 모든 액터의 베이스 클래스.&lt;/li&gt;
  &lt;li&gt;월드 내 플레이어나 AI 개체에 대한 물리적 표현.&lt;/li&gt;
  &lt;li&gt;플레이어의 시각적인 모습 뿐만 아니라, Collision이나 기타 물리적 반응과 같은 측면에서 월드와의 상호작용 방식을 규정.&lt;/li&gt;
  &lt;li&gt;게임 내 플레이어의 물리적 위치, 방향등을 나타냄.&lt;/li&gt;
  &lt;li&gt;Controller와 Pawn은 1:1 대응 관계.(무슨 일이 있어도 각 Controller는 하나의 Pawn만 제어한다.)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;게임 플레이 도중 스폰된 Pawn이 자동적으로 Controller에 Possess되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Character&lt;/li&gt;
  &lt;li&gt;Pawn을 상속 받아서 만든 클래스&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;걸어다닐 수 있는 능력을 지닌 특수 유형 Pawn.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Player Controller&lt;/li&gt;
  &lt;li&gt;클라이언트의 느낌을 많이 받음&lt;/li&gt;
  &lt;li&gt;사용자의 키 입력을 받는다.&lt;/li&gt;
  &lt;li&gt;UI 처리를 담당하는 클래스&lt;/li&gt;
  &lt;li&gt;클라이언트에서 매 프레임마다 검사/체크 하는 로직을 구현하기 좋음&lt;/li&gt;
  &lt;li&gt;클라이언트의 메인 클래스&lt;/li&gt;
  &lt;li&gt;플레이어 컨트롤러가 Pawn을 조종한다.(1:1 대응 관계)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;컴포넌트&quot;&gt;컴포넌트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;게임에서 액터의 주요 기능은 크게 세가지로 나눌 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시각적-기능--플레이어에게-어떻게-보여질-것인가&quot;&gt;시각적 기능 : 플레이어에게 어떻게 보여질 것인가?&lt;/h3&gt;
&lt;h3 id=&quot;물리적-기능--액터의-이동과-액터들-간의-상호-동작을-어떻게-할-것인가&quot;&gt;물리적 기능 : 액터의 이동과 액터들 간의 상호 동작을 어떻게 할 것인가?&lt;/h3&gt;
&lt;h3 id=&quot;움직임--액터가-어떤-움직임을-가질-것인가&quot;&gt;움직임 : 액터가 어떤 움직임을 가질 것인가?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;언리얼엔진은 엔진의 기능을 컴포넌트 단위로 액터에게 제공해준다.&lt;/li&gt;
  &lt;li&gt;액터는 기능별로 존재하진 않음. 액터의 기능을 규격화하여 담당하는 것이 컴포넌트&lt;/li&gt;
  &lt;li&gt;이러한 기능이 컴포넌트로 구분이 되어있는 것&lt;/li&gt;
  &lt;li&gt;하나의 액터 안에 여러개의 컴포넌트를 조합해서 나만의 액터를 만들 수도 있음.&lt;/li&gt;
  &lt;li&gt;액터 안에서 서로의 컴포넌트들이 상호작용을 이루게 됨.
    &lt;blockquote&gt;
      &lt;p&gt;언리얼에서 하는 코딩작업은 이벤트 중심의 게임 동작.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;액터는 여러개의 컴포넌트를 가질 수 있으며, 그 중에서 대표하는 ‘하나의 컴포넌트(Root Component)’를 반드시 지정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스태틱-매쉬-컴포넌트-static-mesh-component&quot;&gt;스태틱 매쉬 컴포넌트 (Static Mesh Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션 되지 않는 매쉬들. 물체. 모델링 에셋&lt;/li&gt;
  &lt;li&gt;시각적인 기능과 물리적인 기능을 제공하는 모듈&lt;/li&gt;
  &lt;li&gt;비디오 메모리에 캐시되고 그래픽 카드에 렌더링할 수 있는 폴리곤 세트로 구성되는 지오메트리 조각&lt;/li&gt;
  &lt;li&gt;비디오 메모리에 저장되기 때문에 위치, 방향, 크기를 조절할 수는 있지만, 어떤식으로든 그 버텍스를 움직일 수는 없다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레벨의 월드 지오메트리를 만드는 데 쓰이는 기본 단위&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;버텍스(Vertex)&lt;/li&gt;
  &lt;li&gt;하나의 ‘점’&lt;/li&gt;
  &lt;li&gt;정점이라 하며, 3D의 가장 기본단위&lt;/li&gt;
  &lt;li&gt;2D의 포인트와 대응되는 개념이지만, 정점은 위치, 색상, 법선 등 다양한 정보를 담고 있다.&lt;/li&gt;
  &lt;li&gt;버텍스와 포인트의 차이
    &lt;ul&gt;
      &lt;li&gt;포인트는 X, Y 좌표값만 가지고 있지만, 버텍스는 위치, 색상, 법선 등의 다양한 정보를 가지고있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;폴리곤(Polygon)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최소의 면단위 (최소 3개의 버텍스가 모여 만들어지는 하나의 면을 ‘폴리곤’이라고 한다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;메쉬 (Mesh)&lt;/li&gt;
  &lt;li&gt;폴리곤들이 모이면 최소한 3차원 공간상의 면을 만든다.&lt;/li&gt;
  &lt;li&gt;폴리곤들이 모여 만들어진 3차원 공간산의 물체(Object) 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스켈레탈-메시-컴포넌트-skeletal-mesh-component&quot;&gt;스켈레탈 메시 컴포넌트 (Skeletal Mesh Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;애니메이션 정보가 있는 모델렝 에셋&lt;/li&gt;
  &lt;li&gt;시각적인 기능과 애니메이션, 캐릭터의 물리 기능을 제공하는 모듈.&lt;/li&gt;
  &lt;li&gt;주로 캐릭터에 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;콜리전-컴포넌트-collision-component&quot;&gt;콜리전 컴포넌트 (Collision Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;물리학에서 두 물체가 서로의 운동에 간섭(충돌)하는 현상을 말한다.&lt;/li&gt;
  &lt;li&gt;언리얼 엔진에서는 액터와 액터 간의 충돌 현상을 처리하는 방식에 대해서 설정할 수 있다.&lt;/li&gt;
  &lt;li&gt;구/박스/캡슐 형태의 지정한 영역의 물리적인 기능을 설정하기 위해 제공하는 모듈&lt;/li&gt;
  &lt;li&gt;액터를 감싸고 있는 컬리전 컴포넌트를 통해서 액터간의 충돌이 일어났는지 여부를 판단한다.&lt;/li&gt;
  &lt;li&gt;단순 컬리전과 복합 컬리전 두가지로 존재한다.&lt;/li&gt;
  &lt;li&gt;스태틱 메시 에디터에서 세팅 옵션에 Collision Complexity(충돌 복잡도) 세팅에서 원하는 값을 세팅할 수 있다.&lt;/li&gt;
  &lt;li&gt;컬리전 옵션으로는 총 세가지가 존재한다.&lt;/li&gt;
  &lt;li&gt;Default : 기본 - 단순 컬리전 요청이 단순컬리전을, 복합 요청은 복합 컬리전을 사용하도록 하는 ‘기본’ 동작.&lt;/li&gt;
  &lt;li&gt;UseSimpleAsComplex : 단순을 복합으로 사용 - 복합 쿼리 요청시에도 엔진은 단순 모양에 대한 쿼리를
 계속, 기본적으로 트라이메시를 무시합니다. 트라이메시를 구울 필요가 없기에 메모리가 절약되고, 컬리전 지오메트리가
 단순해 지면 퍼포먼스가 향상될 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UseComplexAsSimple : 복합을 단순으로 사용 - 단순 쿼리 요청시에도 엔진은 복합 모양에 대한 쿼리를 계속,
 기본적으로 단순 컬리전을 무시합니다. 이를 통해 물리 시뮬레이션 컬리전에 트라이메시를 사용할 수 있습니다. 참고로
 UseComplexAsSimple 사용중인 경우 오브젝트 시뮬레이션은 불가능하나, 다른 시뮬레이션(단순) 오브젝트와의 충돌은 가능합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Construction Script : 새로운 액터 오브젝트를 만들 때 딱 한번 호출되는 함수. / 초기화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;카메라-컴포넌트-camera-component&quot;&gt;카메라 컴포넌트 (Camera Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;플레이어의 모티너 화면에 출력해주는 기능을 담당하는 컴포넌트.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;오디오-컴포넌트-audio-component&quot;&gt;오디오 컴포넌트 (Audio Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;가상 세계에서 소리를 발생시키는 데 사용하는 기능.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파티클-시스템-컴포넌트-particlesystem-component&quot;&gt;파티클 시스템 컴포넌트 (ParticleSystem Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파티클 시스템으로 설계된 이펙트를 화면에 보여주기 위한 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;라이트-컴포넌트-light-component&quot;&gt;라이트 컴포넌트 (Light Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전구, 헤드라이트 등과 같이 물체에 광원 효과를 부여하는 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;무브먼트-컴포넌트-movement-component&quot;&gt;무브먼트 컴포넌트 (Movement Component)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;물체에 특정한 움직임을 부여하는 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;컴포넌트의-분류&quot;&gt;컴포넌트의 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;씬 컴포넌트(Scene Component) : 트랜스폼 정보가 필수적인 컴포넌트.&lt;/li&gt;
  &lt;li&gt;액터 컴포넌트 (Actor Component) : 기능만 제공하는 컴포넌트.&lt;/li&gt;
  &lt;li&gt;씬 컴포넌트는 액터 컴포넌트를 상속받아 트랜스폼 정보를 추가한 클래스이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;c-클래스가-언리얼-오브젝트-클래스가-되기-위한-매크로-규칙&quot;&gt;C++ 클래스가 언리얼 오브젝트 클래스가 되기 위한 매크로 규칙&lt;/h2&gt;
&lt;h3 id=&quot;클래스-선언-매크로--해당-클래스가-언리얼-오브젝트임을-선언하기-위한-매크로이다&quot;&gt;클래스 선언 매크로 : 해당 클래스가 언리얼 오브젝트임을 선언하기 위한 매크로이다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클래스 선언 윗줄에 UCLASS라는 매크로를 선언.&lt;/li&gt;
  &lt;li&gt;클래스 내부에는 GENERATED_BODY 매크로를 선언.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;클래스-이름-접두사--언리얼-오브젝트는-규칙에-맞는-접두사가-붙어야-한다&quot;&gt;클래스 이름 접두사 : 언리얼 오브젝트는 규칙에 맞는 접두사가 붙어야 한다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A와 U, F 접두사가 존재한다.&lt;/li&gt;
  &lt;li&gt;A는 액터 클래스에 사용한다.&lt;/li&gt;
  &lt;li&gt;U는 액터가 아닌 클래스에 사용한다.&lt;/li&gt;
  &lt;li&gt;F는 언리얼 오브젝트와 관련 없는 일반 C++ 클래스 혹은 구조체를 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;generatedh-헤더-파일--언리얼-헤더-툴unreal-header-tool이라는-도구를-사용해-클래스-선언을-분석하고-언리얼-실행-환경에-필요한-부가-정보를-별도의-파일에-생성한다&quot;&gt;generated.h 헤더 파일 : 언리얼 헤더 툴(Unreal Header Tool)이라는 도구를 사용해 클래스 선언을 분석하고, 언리얼 실행 환경에 필요한 부가 정보를 별도의 파일에 생성한다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코드를 작성하는 시점에 이파일은 존재하지 않지만, 컴파일 과정에서 필연적으로 발생한다.&lt;/li&gt;
  &lt;li&gt;언리얼 오브젝트 선언의 마지막 #include 구문에 이 헤더파일을 반드시 선언해줘야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;외부-모듈에의-공개-여부--언리얼-엔진에서-다른-모듈에서-해당-객체에-접근하게-할-수-있도록-지정-여부-판단&quot;&gt;외부 모듈에의 공개 여부 : 언리얼 엔진에서 다른 모듈에서 해당 객체에 접근하게 할 수 있도록 지정 여부 판단.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클래스 선언 앞에 ‘모듈명_API’ 키워드를 추가한다.&lt;/li&gt;
  &lt;li&gt;이 키워드가 없으면 다른 모듈에서 해당 객체에 접근할 수 없다.&lt;/li&gt;
  &lt;li&gt;윈도우 DLL 시스템의 _declspec(dllexport) 키워드를 언리얼에서 사용하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;언리얼-엔진에서-컴포넌트를-생성하는-함수&quot;&gt;언리얼 엔진에서 컴포넌트를 생성하는 함수&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CreateDefaultSubobject API&lt;/li&gt;
  &lt;li&gt;언리얼 엔진에서는 new 키워드가 아닌 위의 함수로 컴포넌트를 생성할 수 있다.&lt;/li&gt;
  &lt;li&gt;CreateDefaultSubobject API에 사용하는 문자열 값은 액터에 속한 컴포넌트를 구별하기 위한 Hash 값 생성에 사용된다.&lt;/li&gt;
  &lt;li&gt;어떤 값을 넣어도 상관없지만, 다른 컴포넌트와 중복되지 않는 유일한 값을 지정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;액터-이벤트&quot;&gt;액터 이벤트&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;PostInitializeComponents : 액터에 속한 모든 컴포넌트의 세팅이 완료됬을 때 호출되는 함수.&lt;/li&gt;
  &lt;li&gt;BeginPlay : 게임이 시작 될 때, BeginPlay가 정의가 된 액터들은 딱 한번만 호출한다.(초기화)&lt;/li&gt;
  &lt;li&gt;Construction Script : BeginPlay와 비슷하지만, 이 함수는 액터를 직접 배치할 때와 디테일의 값을 변경할 때 호출된다.(게임이 실행될 때는 호출하지않음.)
동적 스폰을 통해 생성할 때는 Construction Script -&amp;gt; BeginPlay가 호출된다.&lt;/li&gt;
  &lt;li&gt;Tick : 게임 시뮬레이션을 한번 돌 때마다 호출되는 함수. 지속적으로 값을 바꾸는 작업을 할 때 사용.&lt;/li&gt;
  &lt;li&gt;Tick 이벤트 : 틱당 계속 호출되는 이벤트&lt;/li&gt;
  &lt;li&gt;60 프레임 : 1초에 60번 계산을 한다.&lt;/li&gt;
  &lt;li&gt;End Play : 액터가 삭제 될 때 호출되는 이벤트&lt;/li&gt;
  &lt;li&gt;EndPlayReason : 액터가 삭제되는 이유&lt;/li&gt;
  &lt;li&gt;Collision OnComponent Begin Overlap : 액터가 충돌이 일어나는 시점에 발생하는 이벤트&lt;/li&gt;
  &lt;li&gt;Collision OnComponent End Overlap : 액터가 충돌이 끝난 시점에 발생하는 이벤트&lt;/li&gt;
  &lt;li&gt;ActorBeginOverlap : 내가 가지고 있는 하위 컴포넌트 중에 begin overlap이 발생하면, 같이 호출되는 이벤트&lt;/li&gt;
  &lt;li&gt;Delay : 지정한 시간(Duration)동안 다음 노드로 가기 전까지 시간을 기다린 후 다음 노드를 진행하는 함수.&lt;/li&gt;
  &lt;li&gt;Custom Event : 엔진에서 제공하는 이벤트가 아닌, 프로그래머가 직접 이벤트를 생성하여 로직을 작성하여 원할 때 호출할 수 있도록 작성할 수 있다.&lt;/li&gt;
  &lt;li&gt;Deactivate : 기능 컴포넌트를 비활성화를 시키는 함수.&lt;/li&gt;
  &lt;li&gt;Activate : 기능 컴포넌트를 활성화 시키는 함수.&lt;/li&gt;
  &lt;li&gt;Set Visibility : 물체가 레벨에 눈으로 볼 수 있도록 표현 되어있는 컴포넌트는 이를 통해서 보여지거나, 감출 수 있다.&lt;/li&gt;
  &lt;li&gt;Propagate to Children : 해당 액터(또는 컴포넌트)의 자식 액터들까지 영향을 미치게 하는 기능.&lt;/li&gt;
  &lt;li&gt;OverLab : 액터의 컬리전들끼리 겹치는 현상을 말함.&lt;/li&gt;
  &lt;li&gt;SphereOverlapActors : 해당 액터 주위에 다른 액터가 있는지 검사할 수 있는 함수. 비슷한 함수로 Box, Capsule, ComponentOverlapActors가 있다.
    &lt;ul&gt;
      &lt;li&gt;Return 값은 boolean 값으로, 조건에 해당하는 액터가 있을 경우 true, 그렇지 않을 경우 false를 리턴.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;액터-병합-기능&quot;&gt;액터 병합 기능&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;물체를 하나로 합쳐주는 기능.&lt;/li&gt;
  &lt;li&gt;잘 활용하면 외부 모델링을 게임의 최적화 상태로 스태틱 메쉬 컴포넌트 데이터를 변경해줄 수 있다.&lt;/li&gt;
  &lt;li&gt;이 때 각각의 오브젝트에 있는 스태틱 메쉬 컴포넌트의 리소스를 합쳐 하나의 새로운 스태틱 메쉬 컴포넌트 리소스로 제작해주는 기능.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Apr 2018 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/unreal/2018/04/05/about-actor.html</link>
        <guid isPermaLink="true">http://localhost:4000/unreal/2018/04/05/about-actor.html</guid>
        
        <category>Actor</category>
        
        <category>Unreal</category>
        
        <category>UnrealEngine</category>
        
        
        <category>Unreal</category>
        
      </item>
    
      <item>
        <title>Singleton Pattern</title>
        <description>&lt;h1 id=&quot;singleton-pattern&quot;&gt;Singleton Pattern&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;instance란&quot;&gt;Instance란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;객체(Object)를 생성하여 Heap 메모리 영역에 할당된 실체(Stack된 것)를 의미하는 개념.
&lt;br /&gt;
    &lt;h2 id=&quot;singleton이란&quot;&gt;Singleton이란?&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;OOP에서의 객체는 Class와 Instance를 포함한 개념&lt;/li&gt;
  &lt;li&gt;하나의 프로그램 내에서 인스턴스가 사용될 때, 이전에 생성된 인스턴스가 있을 경우 동일한 인스턴스를 생성하는 것이 아닌, 기존에 생성되어 있던 인스턴스를 가져와 사용하는 것을 기본 전략으로 내세운 디자인 패턴이다.&lt;/li&gt;
  &lt;li&gt;프로그램 상에서 동일한 커넥션 객체를 만든다든지, 하나만 사용되어야 하는 객체를 만들때 유용하다. 
&lt;br /&gt;
    &lt;h2 id=&quot;singleton-패턴을-사용하는-이유는&quot;&gt;Singleton 패턴을 사용하는 이유는?&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;지정한 클래스 인스턴스가 프로그램이 작동할 때 단 한개만을 생성하여 유지하고 싶을 경우&lt;/li&gt;
  &lt;li&gt;new 키워드를 통해 객체를 생성하게 되면, 생성되는 클래스의 인스턴스가 Heap 메모리 영역으로 올라가게 되고, 그 인스턴스를 가리키고 있는 변수는 Stack 메모리 영역에 생기게 된다. 
이렇게 될 경우, 메모리의 낭비가 심해져 누적될 경우 프로세스 처리 시간이 길어질 수 있다.&lt;/li&gt;
  &lt;li&gt;프로그램에서 지속적으로 유지가 되어야하는 정보(ex. 유저 정보 또는 프로그램의 커스텀 정보 등)를 저장/불러오기에 용이하다.
&lt;br /&gt;
    &lt;h2 id=&quot;singleton-패턴의-단점&quot;&gt;Singleton 패턴의 단점&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램의 Coupling을 높이게 되어 추가 수정의 작업이 있을 경우 사이드 이펙트의 이슈를 가지고 있다.&lt;/li&gt;
  &lt;li&gt;멀티 쓰레드 응용 프로그램에서 명시적 초기화가 필요한 경우, 쓰레딩 문제를 예방하기 위해 조치를 취해야한다.&lt;/li&gt;
  &lt;li&gt;멀티 쓰레드 환경에서 사용할 경우, 한 싱글턴 클래스를 여러 쓰레드에서 사용 및 변경하게 되면, 동기화의 이슈가 생기게 된다.&lt;/li&gt;
  &lt;li&gt;이에 lock을 통해서 쓰레드에서 접근할 때 순차적으로 접근하여 한 쓰레드 씩 사용할 수 있게 처리해줘야 안전하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;참고자료
[Java]Singleton이란/사용이유/구현방법 : http://mkil.tistory.com/199&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2017/12/07/about-singleton.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2017/12/07/about-singleton.html</guid>
        
        <category>OOP DesignePattern</category>
        
        <category>Singleton</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>객체지향의 3요소 5원칙(Object-Oriented Programming)</title>
        <description>&lt;h1 id=&quot;객체지향의-3요소-5원칙&quot;&gt;&lt;strong&gt;객체지향의 3요소 5원칙&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;3요소&quot;&gt;3요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캡슐화, 다형성, 상속
&lt;br /&gt;
    &lt;h3 id=&quot;encapsulation-캡슐화&quot;&gt;Encapsulation 캡슐화&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램 내에서 같은 기능을 목적으로 작성된 코드를 모아서 다른 곳(클래스)에서 안보이게 숨기는 것.&lt;/li&gt;
  &lt;li&gt;클래스에 정의된 속성(Attribute)는 숨기고(Private), 객체가 수행할 기능(Function)은 공개(Public)하는 것을 의미한다.
&lt;br /&gt;
    &lt;h3 id=&quot;inheritance-상속&quot;&gt;Inheritance 상속&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스 사이에 부모와 자식 클래스가 존재할 수 있다는 뜻.&lt;/li&gt;
  &lt;li&gt;자식 클래스는 상속받은 부모 클래스의 속성(변수) 및 기능(메소드, 함수)를 물려받는 것을 의미한다.
&lt;br /&gt;
    &lt;h3 id=&quot;polymorphism-다형성&quot;&gt;Polymorphism 다형성&lt;/h3&gt;
    &lt;p&gt;Overriding과 Overloading 두가지로 나뉨.&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;Overriding&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;부모클래스에서 정의되어 있는 내용을 자식클래스에서 재정의하여 사용하는 것.
    &lt;ol&gt;
      &lt;li&gt;Overloading&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;같은 이름을 가진 메소드(함수)를 인자값의 종류에 따라 여러개 만들수 있다.&lt;/li&gt;
  &lt;li&gt;같은 이름의 메소드라고 하더라도, 원하는 기능이 상이할 수 있으니, 메소드가 받는 인자의 종류 또는 숫자를 다르게 하여 기능을 정의하는 것.
&lt;br /&gt;
    &lt;h2 id=&quot;5원칙&quot;&gt;5원칙&lt;/h2&gt;
    &lt;h3 id=&quot;solid&quot;&gt;SOLID&lt;/h3&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
    &lt;h4 id=&quot;s---srp단일-책임의-원칙--single-responsibility-principle&quot;&gt;S -&amp;gt; SRP(단일 책임의 원칙 : Single Responsibility Principle)&lt;/h4&gt;
    &lt;p&gt;‘There should never be more than one reason for a class to change’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임(axis of change)을 수행하는 데 집중되어 있어야 한다는 원칙입니다.&lt;/li&gt;
  &lt;li&gt;이는 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 함을 의미합니다.&lt;/li&gt;
  &lt;li&gt;SRP 원리를 적용하면 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있습니다.&lt;/li&gt;
  &lt;li&gt;코드의 가독성 및 유지보수에 있어서 유리합니다.&lt;/li&gt;
  &lt;li&gt;객체 지향 프로그래밍의 5원칙 중 나머지 4원칙의 기초가 되는 원칙입니다.
&lt;br /&gt;
    &lt;h4 id=&quot;o---ocp개방폐쇄의-원칙-open-close-principle&quot;&gt;O -&amp;gt; OCP(개방폐쇄의 원칙: Open Close Principle)&lt;/h4&gt;
    &lt;p&gt;‘You should be able to extend a classes behavior, without modifying it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리입니다.&lt;/li&gt;
  &lt;li&gt;이것은 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다는 의미로, 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻입니다.&lt;/li&gt;
  &lt;li&gt;재사용 코드를 만드는 기반이며, OCP를 가능하게 하는 중요 메커니즘은 추상화와 다형성.(Written By Robert C. Martin)&lt;/li&gt;
  &lt;li&gt;객체지향의 장점을 극대화하는 중요한 원리.
&lt;br /&gt;
    &lt;h4 id=&quot;l---lsp리스코브-치환의-원칙-the-liskov-substitution&quot;&gt;L -&amp;gt; LSP(리스코브 치환의 원칙: The Liskov Substitution)&lt;/h4&gt;
    &lt;p&gt;‘FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;자식 클래스(서브 타입)는 언제나 자신의 부모 클래스(기반 타입)를 대체할 수 있다. 즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것.&lt;/li&gt;
  &lt;li&gt;상속의 본질인 원리&lt;/li&gt;
  &lt;li&gt;이를 지키지 않을 경우 부모 클래스 본래의 의미가 변해서 is a 관계가 무너짐
&lt;br /&gt;
    &lt;h4 id=&quot;i---isp인터페이스-분리의-원칙-interface-segregation-principle&quot;&gt;I -&amp;gt; ISP(인터페이스 분리의 원칙: Interface Segregation Principle)&lt;/h4&gt;
    &lt;p&gt;‘Client should not be forced to depend upon interfaces that they do not use.’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리.&lt;/li&gt;
  &lt;li&gt;어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 합니다.
&lt;br /&gt;
    &lt;h4 id=&quot;d---dip의존성역전의-원칙-dependency-inversion-principle&quot;&gt;D -&amp;gt; DIP(의존성역전의 원칙: Dependency Inversion Principle)&lt;/h4&gt;
    &lt;p&gt;‘High level modules should not depend upon low level modules. Both should depend upon abstractions.’
‘Abstractions should not depend upon details. Details should depend upon abstractions.’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의역전입니다.&lt;/li&gt;
  &lt;li&gt;실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙입니다.
&lt;br /&gt;
참고 : 
http://www.nextree.co.kr/p6960/
https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99#s-2.3&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2017/12/07/about-oop.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2017/12/07/about-oop.html</guid>
        
        <category>OOP</category>
        
        <category>Encapsulation</category>
        
        <category>Inheritance</category>
        
        <category>Polymorphism</category>
        
        <category>객체지향</category>
        
        <category>3요소</category>
        
        <category>5원칙</category>
        
        <category>캡슐화</category>
        
        <category>상속</category>
        
        <category>다형성</category>
        
        <category>SOLID</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>MVP Pattern</title>
        <description>&lt;h1 id=&quot;mvp-패턴-&quot;&gt;MVP 패턴 !!&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;mvp-패턴이란&quot;&gt;MVP 패턴이란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1990년대 초기 MS사에서 공개한, MVC 기반의 GUI를 처리하기 위한 패턴&lt;/li&gt;
  &lt;li&gt;MVC 패턴에 비해 Model과 View 간의 결합도를 낮추는데 초점을 맞춤.&lt;/li&gt;
  &lt;li&gt;View, Model, Presenter로 나뉨
&lt;br /&gt;
    &lt;h2 id=&quot;장점&quot;&gt;장점&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;MVC 패턴에 비해 클래스별 코드가 짧아짐.&lt;/li&gt;
  &lt;li&gt;코드를 나눔으로써 TDD 주도 개발이 수월해짐&lt;/li&gt;
  &lt;li&gt;View와 Model 간의 구분 가능&lt;/li&gt;
  &lt;li&gt;Presenter의 역할을 통해 View와 Model 간의 결합도를 낮출 수 있음&lt;/li&gt;
  &lt;li&gt;결합도가 낮아짐에 따라 새로운 기능 추가 또는 변경 등, 유지보수 및 확장성이 좋아짐.&lt;/li&gt;
  &lt;li&gt;View와 Model의 사용법이 분리되면서 Clean Code가 가능하다.&lt;/li&gt;
  &lt;li&gt;Presenter의 역할을 통해 Model과 View 간의 결합도를 낮출 수&lt;/li&gt;
  &lt;li&gt;클래스의 역할에 따라 코드를 분배하는 패턴
&lt;br /&gt;
    &lt;h2 id=&quot;view-presenter-model&quot;&gt;View, Presenter, Model&lt;/h2&gt;
    &lt;h3 id=&quot;view&quot;&gt;View&lt;/h3&gt;
    &lt;ol&gt;
      &lt;li&gt;어플리케이션의 인터페이스&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자에게는 View가 곧 Interface
    &lt;ol&gt;
      &lt;li&gt;실제 View에 접근하고 화면을 갱신하는 역할을 수행&lt;/li&gt;
      &lt;li&gt;Presenter에 의존적&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;이벤트를 Presenter에 전달&lt;/li&gt;
  &lt;li&gt;Presenter에서 데이터를 전달받아서 사용자에게 알맞은 화면 제공&lt;/li&gt;
  &lt;li&gt;Presenter가 보내주는 데이터에 따라 로딩 / 경고 / 대화창 등을 표현
    &lt;ol&gt;
      &lt;li&gt;View는 또다시 Interface와 View Component(구현체)로 구분할 수있는데,&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Interface&lt;/li&gt;
  &lt;li&gt;사용자에게 보여질 기능을 정의&lt;/li&gt;
  &lt;li&gt;Presenter가 호출할 기능을 정의
    &lt;ol&gt;
      &lt;li&gt;View Component&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Interface에 정의한 기능의 구현 제공&lt;/li&gt;
  &lt;li&gt;사용자 이벤트를 Presenter에 전달
&lt;br /&gt;
    &lt;h3 id=&quot;presenter&quot;&gt;Presenter&lt;/h3&gt;
    &lt;ol&gt;
      &lt;li&gt;Model과 View를 연결 (매개체)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;MVP에서 Presenter는 기능/흐름을 제공&lt;/li&gt;
  &lt;li&gt;요구사항이 Presenter의 기능에 대응
    &lt;ol&gt;
      &lt;li&gt;사용자 요청에 반응&lt;/li&gt;
      &lt;li&gt;View의 흐름 제어
&lt;br /&gt;
        &lt;h3 id=&quot;model&quot;&gt;Model&lt;/h3&gt;
      &lt;/li&gt;
      &lt;li&gt;내부적으로 사용되는 데이터를 저장하고, 처리하는 역할.&lt;/li&gt;
      &lt;li&gt;‘비즈니스 로직’과 ‘어플리케이션 데이터’&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;인증&lt;/li&gt;
  &lt;li&gt;위치 데이터&lt;/li&gt;
  &lt;li&gt;그 외 네트워크 통신 등
    &lt;ol&gt;
      &lt;li&gt;Presenter가 요청한 작업을 수행
&lt;br /&gt;
&lt;br /&gt;
참조한 사이트 주소 !! 한번씩 읽어보시면 상세한 설명을 해주셔서 큰 도움이 됩니다.
[MVP for Android: how to organize the presentation layer] - https://antonioleiva.com/mvp-android
[Adapter, 누구냐 넌? - Data? View?] - https://medium.com/@jsuch2362/adapter-%EB%88%84%EA%B5%AC%EB%83%90-%EB%84%8C-data-view-2db7eff11c20
[Android MVP 무작정 따라하기] - http://thdev.tech/androiddev/2016/10/12/Android-MVP-Intro.html
&lt;br /&gt;
관련 예제
https://github.com/TonyChoiMS/DaggerExample (- Dagger Example의 경우 참고 git이 있었는데 찾지 못하고있습니다. 혹시 주소를 아시는분은 댓글로 알려주시면 감사하겠습니다!)
https://github.com/antoniolg/androidmvp
https://github.com/hitherejoe/Bourbon
https://github.com/taehwandev/AndroidMVPSample
https://medium.com/@nurrohman/a-simple-android-apps-with-mvp-dagger-rxjava-and-retrofit-4edb214a66d7&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2017/12/07/about-mvp.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2017/12/07/about-mvp.html</guid>
        
        <category>MVP</category>
        
        <category>MVP Pattern</category>
        
        <category>Android</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>C++ Linked List.</title>
        <description>&lt;p&gt;[최종 수정일 : 2021-04-29]&lt;/p&gt;

&lt;h1 id=&quot;링크드리스트&quot;&gt;&lt;strong&gt;링크드리스트&lt;/strong&gt;&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;데이터의 메모리주소의 순서가 순차적으로 이루어져있지 않다.
    &lt;ul&gt;
      &lt;li&gt;1번 뒤에 2번이 있다는 보장이 없음&lt;/li&gt;
      &lt;li&gt;노드(링크)에 의해 논리적으로 연결되어 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Single LinkedList와 Double LinkedList 두종류로 존재함.
    &lt;ul&gt;
      &lt;li&gt;Double LinkedList의 경우엔 내 다음 노드(Next) 뿐만 아니라, 이전 노드(Prev)의 주소정보까지 가지고있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;임의 접근(Random Access)이 불가능함.
    &lt;ul&gt;
      &lt;li&gt;현재의 노드가 알 수 있는 건 바로 내 다음의 노드의 존재만이기때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 삽입/삭제에 있어서 강점이 있음
    &lt;ul&gt;
      &lt;li&gt;물리적인 메모리 이동없이 요소간의 링크만 조작하면 되므로 속도에 유리.&lt;/li&gt;
      &lt;li&gt;삽입할 위치의 이전 노드의 다음 노드포인터(Next)에 삽입할 노드를 연결하고, 삽입할 노드의 다음 노드포인터(Next)에 이전 노드의 Next에 저장되있던 포인터를 저장합니다.&lt;/li&gt;
      &lt;li&gt;삭제 할 노드 앞 뒤를 서로 연결한 후, 삭제할 데이터의 노드를 삭제.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리의 낭비가 없음
    &lt;ul&gt;
      &lt;li&gt;배열의 형식처럼 미리 Size를 선언한 뒤, 사용하는 것이 아닌, 노드의 추가 / 삭제 할 때 메모리 할당을 하기 때문.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 노드에 여러개의 변수 또는 데이터값을 포함할 수 있다.&lt;/li&gt;
  &lt;li&gt;다음 노드가 NULL을 가리킬 경우, 리스트의 끝(마지막 노드)이라는 뜻. 
&lt;br /&gt;
// Single LinkedList 예시&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;LinkedList.h&quot;

using namespace std;

LinkedList::LinkedList() {
	head-&amp;gt;nextNode = NULL;
	LinkedList::Count = 0;
}

LinkedList::~LinkedList() {
	
}

int LinkedList::get(int index) {
	try {
		valid(index);
	}
	catch (const char* msg) {
		cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; endl;
		return -1;
	}
	Node* temp = head;
	for (int i = 0; i &amp;lt;= index; i++) {
		temp = temp-&amp;gt;nextNode;
	}
	return temp-&amp;gt;data;
}

void LinkedList::valid(int count) {
	if (count &amp;gt; LinkedList::Count) {
		throw &quot;Error : À¯È¿ÇÏÁö ¾ÊÀº index&quot;;
	}
}

void LinkedList::add(int data) {
	Node* newNode = new Node;
	newNode-&amp;gt;data = data;
	newNode-&amp;gt;nextNode = NULL;

	if (head-&amp;gt;nextNode == NULL) {
		head-&amp;gt;nextNode = newNode;
	}
	else {
		Node* temp = head;
		while (temp-&amp;gt;nextNode != NULL) {
			temp = temp-&amp;gt;nextNode;
		}
		temp-&amp;gt;nextNode = newNode;
	}
	LinkedList::Count++;
}

void LinkedList::add(int index, int data) {
	try {
		valid(index);
	}
	catch (const char* msg) {
		cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; endl;
		return;
	}

	Node* newNode = new Node;
	newNode-&amp;gt;data = data;
	newNode-&amp;gt;nextNode = NULL;

	if (head-&amp;gt;nextNode == NULL) {
		head-&amp;gt;nextNode = newNode;
	}
	else {
		Node* temp = head;
		for (int i = 0; i &amp;lt; Count; i++) {
			temp = temp-&amp;gt;nextNode;
		}
		newNode-&amp;gt;nextNode = temp-&amp;gt;nextNode;
		temp-&amp;gt;nextNode = newNode;
	}
	LinkedList::Count++;
}

int LinkedList::size() {
	return LinkedList::Count;
}

void LinkedList::set(int index, int data) {
	try {
		valid(index);
	}
	catch (const char* msg) {
		cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; endl;
		return;
	}

	Node* temp = head;
	for (int i = 0; i &amp;lt;= index; i++) {
		temp = temp-&amp;gt;nextNode;
	}
	temp-&amp;gt;data = data;
}

void LinkedList::remove(int index) {
	try {
		valid(index);
	}
	catch (const char* msg) {
		cout &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; endl;
		return;
	}

	Node* temp = head;
	Node* remove = head;

	for (int i = 0; i &amp;lt; index; i++) {
		temp = temp-&amp;gt;nextNode;
		remove = remove-&amp;gt;nextNode;
	}
	remove = remove-&amp;gt;nextNode;

	temp-&amp;gt;nextNode = remove-&amp;gt;nextNode;
	remove-&amp;gt;nextNode = NULL;
	delete remove;
	LinkedList::Count++;
}

bool LinkedList::isEmpty() {
	Node* nodeHead = head;
	if (nodeHead-&amp;gt;nextNode == NULL) {
		return true;
	}
	else {
		return false;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;
예제 URL : https://github.com/TonyChoiMS/DataStructure/tree/master/DataStructureLib/DataStructureLib&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2017/12/07/about-linkedlist.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2017/12/07/about-linkedlist.html</guid>
        
        <category>C++</category>
        
        <category>LinkedList</category>
        
        <category>Double LinkedList</category>
        
        
        <category>Programming</category>
        
      </item>
    
      <item>
        <title>Dependency 의존성</title>
        <description>&lt;h1 id=&quot;dependency&quot;&gt;&lt;strong&gt;Dependency!!&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;MVP Pattern을 알기 전에 Dependency(의존성)에 대해서 한번 알아보자
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;dependency란&quot;&gt;Dependency란?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;코드에서 두 모듈 간의 연결.&lt;/li&gt;
  &lt;li&gt;객체지향언어에서는 두 클래스 간의 관계라고도 말함.&lt;/li&gt;
  &lt;li&gt;일반적으로 둘 중 하나가 다른 하나를 어떤 용도를 위해 사용함.
&lt;br /&gt;
    &lt;h2 id=&quot;dependency가-위험한-이유&quot;&gt;Dependency가 위험한 이유&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경이 이루어지기 때문.&lt;/li&gt;
  &lt;li&gt;테스트 가능한 어플을 만들 때 의존성이 있으면 유닛테스트 작성이 어려움.&lt;/li&gt;
  &lt;li&gt;유닛테스트의 목적 자체가 다른 모듈로부터 독립적으로 테스트하는 것을 요구하기 때문.(Mock 객체로 대체가능)
&lt;br /&gt;
    &lt;h2 id=&quot;dependency-injection의존성-주입이-필요한-이유&quot;&gt;Dependency Injection(의존성 주입)이 필요한 이유&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;위 Dependency가 위험한 이유를 해결하기 위해서 사용.&lt;/li&gt;
  &lt;li&gt;‘new’ 키워드를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참조하면 된다.&lt;/li&gt;
  &lt;li&gt;의존성 주입은 Inversion of Control 개념을 바탕으로 합니다. 클래스가 외부로부터 의존성을 가져야합니다.&lt;/li&gt;
  &lt;li&gt;클래스는 다른 클래스를 인스턴스화해야 하지만, 구성 클래스에서 인스턴스를 가져와야 합니다.&lt;/li&gt;
  &lt;li&gt;Java 클래스가 new 연산자를 통해 다른 클래스의 인스턴스를 생성하면 해당 클래스와 독립적으로 테스트하고 사용할 수 없으며 이를 하드종속성이라고 합니다.
&lt;br /&gt;
    &lt;h2 id=&quot;클래스-외부에서-종속성을-제공하면-생기는-이점&quot;&gt;클래스 외부에서 종속성을 제공하면 생기는 이점&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할  수 있습니다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적
&lt;br /&gt;
    &lt;h2 id=&quot;의존성-주입dependency-injection을-어떻게-할-것인가&quot;&gt;의존성 주입(Dependency Injection)을 어떻게 할 것인가?&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Contructor Injection : 생성자 삽입&lt;/li&gt;
  &lt;li&gt;Field Injection : 멤버 변수 삽입( 비공개 안됨)&lt;/li&gt;
  &lt;li&gt;Method Injection : 메소드 매게 변수 삽입.
&lt;br /&gt;
    &lt;h2 id=&quot;jsr330에-따른-종속성-주입-순서&quot;&gt;JSR330에 따른 종속성 주입 순서&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Constructor&lt;/li&gt;
  &lt;li&gt;Field&lt;/li&gt;
  &lt;li&gt;Method&lt;/li&gt;
  &lt;li&gt;@Inject로 주석처리된 메소드나 필드가 호출되는 순서는 JSR330에 의해 정의되지 않습니다. 
&lt;br /&gt;
    &lt;h3 id=&quot;종속성-소비자는-커넥터를-통해-종속성-공급자의-종속성object을-필요로-합니다&quot;&gt;종속성 소비자는 커넥터를 통해 종속성 공급자의 종속성(Object)을 필요로 합니다.&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Dependency provider : @Module 어노테이션 된 클래스는 삽입 할 수 있는 객체를 제공합니다. 이러한 클래스는 @Provides 어노테이션메소드를 정의합니다(@Module -&amp;gt; @Provides) 이 메소드의 리턴된 오브젝트는 종속성 삽입에 사용 가능합니다.&lt;/li&gt;
  &lt;li&gt;Dependency consumer : @Inject 어노테이션은 의존성을 정의하는데 사용된다.&lt;/li&gt;
  &lt;li&gt;Connecting consumer and producer : @Component 어노테이션 인터페이스는 객체 제공자(Module)와 의존 관계를 표현하는 객체 사이의 연결을 정의합니다. 이 연결에 대한 클래스는 Dagger에 의해 생성됩니다.
&lt;br /&gt;
    &lt;h2 id=&quot;dependency-injector란&quot;&gt;Dependency Injector란?&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;모듈의 인스턴스를 제공하며 의존성을 주입하는 모듈
&lt;br /&gt;
예제 및 참고 페이지
[아키텍트 코스 - Dependency Injection 이해하기] - http://imcreator.tistory.com/106 
[Dagger2 소개, 안드로이드에서 Dependency Injection 사용하기 전에] - http://www.kmshack.kr/2017/06/dagger-2-%EC%86%8C%EA%B0%9C-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-dependency-injection-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0%EC%A0%84%EC%97%90/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 Dec 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/2017/12/07/about-dependency.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/2017/12/07/about-dependency.html</guid>
        
        <category>Dependency</category>
        
        <category>mvp pattern</category>
        
        
        <category>Programming</category>
        
      </item>
    
  </channel>
</rss>
