---
layout: post
title:  "C++ 용어에 대한 정리"
date: 2020-05-24
desc: "C++의 기본에 대해 공부하며 정리하는 목록."
keywords: "C++"
categories: [C++, Programming]
comments: true
tags: [C++, programming]
icon: icon-html
---

[최종수정 2021-04-30]

# __C++ 용어정리 !!__
C++ 스타일의 캐스팅

  
## namespace
 - 코드 안에서 같은 이름으로 변수와 함수 이름을 지어야 할 상황이 발생할 수 있습니다.
 - 그리고 외부에서 참조하는 소스를 사용하다 보면 같은 이름의 변수나 함수가 있어서 난감한 상황이 생길 수 있습니다.
 - 이러한 문제를 해결하기 위해 고안된 것이 네임스페이스 입니다.
 - 네임스페이스는 변수나 함수를 해당 영역에서만 유효하도록 제한하는 것입니다.
  
## static_cast<>
 - 가장 기본적인 캐스트 연산 방법
  
## dynamic_cast<>
 - 객체지향 언어의 다형성을 이용하여 모호한 타입 캐스팅 오류를 막아주는 역할
  
## const_cast<>
 - 자료형이 갖고 있는 상수 속성을 제거하는 캐스팅
  
## reinterpret_cast<>
 - 어떠한 포인터 타입끼리도 변환할 수 있게 도움을 주는 캐스팅
  

  
## 포인터
 - 변수의 주소를 가리키는 것. 
 - *(Asterisk)가 붙은 변수는 실제 값이 아니라 주소를 저장한다는 의미입니다.
 - 그렇기 때문에 포인터 변수를 출력하게 되면 실제 값이 아닌 메모리주소값을 확인 할 수 있습니다.
 - 이 주소값은 사용자가 임의로 주소를 지정할 순 있지만, 대체로 컴퓨터 내부적으로 할당하고 그 값을 이용하고 있습니다.
 - &(Ampersand)는 변수의 주소를 불러오는 의미입니다.
 - * 또는 &이 붙어있는 변수의 크기를 출력하게 되면 변수가 가지고 있는 자료형의 크기가 아닌, 포인터의 크기를 출력하게 됩니다.(4Byte)
 - 포인터를 사용하면 프로그램 전체 성능을 올리는데 도움이 되기도 합니다.
 - 함수는 인자로 넘어오는 값을 복사하여 사용하는데, 만약 인자가 크다면 복사하는데 많은 시간이 소요됩니다.
 - 이 때 인자로 포인터를 넘겨줄 경우 4byte(64비트의 경우 8byte) 주소만 넘겨주도록 할 수 있기 때문에 훨씬 효율적입니다.
  
 ## 포인터 배열
  - 배열을 하나 선언하고 포인터 변수에 그 주소를 지정할 경우, 해당 변수는 배열의 제일 첫 인덱스 주소를 가리키고 있게 됩니다.
  - 이 때 변수에 증감 연산자를 통해 주소를 증가시키면 포인터가 배열의 뒤쪽의 인덱스를 가리키게 변경됩니다.
  - 배열은 선언과 함께 초기화 하는 습관이 중요합니다.
  - 만약 배열을 초기화하지 않으면 쓰레기 값이 들어가 나중에 버그 등이 발생할 떄 원인이 되기도 합니다.
  
## 변수의 유효범위
 - 변수는 값이 저장되는 메모리 영역이나 변수의 유효범위에 따라 구분되는데, auto, static, extern 이 세가지 키워드를 이용하여 구분을 할 수 있습니다.
 - 변수의 유효범위는 크게 지역변수(local variable)와 전역변수(global vriable)로 나뉘며, 실제 프로그램 실행시에 변수가 저장되는 메모리상의 위치에 따라
   높은 주소값부터 사용하는 stack, 낮은 주소값부터 사용하는 정적 데이터 영역(.data, .bss)과 힙(heap)으로 구분됩니다.
 - 최적화 관점에서 살펴보면, 스택의 경우 해당 Scope에서 자주 액세스 되며 범위가 끝나면 없어지는 임시 변수들이 저장되는데, 스택포인터를 순차적으로
   이동해가며 할당되기 때문에 할당 속도가 빠르며, 해당 변수들이 자주사용되서 CPU 캐시의 히트율이 높은 경우 접근 속도도 더 빨라진다. 하지만 Scope가 끝나면
   없어지기 때문에 계속적으로 값을 유지하는 것이 불가능하다. 
 - 정적인 변수들은 정적 데이터 영역에 저장하여 계속 유지되며, 동적인 변수들은 힙에 변수를 할당하고 저장한다. 
 - 힙은 비순차적 메모리 할당/해제가 계속 일어나는 동적인 특성을 가지고 있다.
 - 그렇기 때문에 스택처럼 메모리 할당을 순차적으로 하기가 힘들어서 정적인 방식에 비해 할당 속도가 느린 특성을 갖는다.
  
### 정적 변수(static)
 - 블럭 안에서만 유효한 값을 가지지만 자동변수와 같이 없어지지 않고 블럭으로 다시 돌아왔을 때 이전 값을 다시 이용 가능한 변수입니다.
 - 스택이 아닌 정적데이터 영역에 저장되는 변수입니다.
 - 초기화를 생략하면 0으로 자동 초기화됩니다.
  
### 전역 변수 (extern)
 - 함수 밖의 전역 범위에 선언되며, 프로그램 전체에서 유효하고 다른 파일에서 참조 가능한 변수입니다.
 - 초기화를 생략하면 0으로 자동 초기화가 진행됩니다.
 - 정적 데이터영역에 할당됩니다.
 - extern 변수는 편리하지만, 남발하면 프로그램을 복잡하게 하고 나중에 유지보수가 힘들기 때문에 사용을 최소화 하는 것이 바람직합니다.

  
## Call by Value
 - 함수의 인자로 넘어온 값을 내부적으로 복사해서 사용합니다.
 - 그러므로 인자로 넘어온 값을 변경한다 하더라도, 인자로 넘긴 변수를 변경한 것이 아닌, 복사된 값만 변경한 것이기 때문에 함수 종료 후 해당 값을 다시 확인해보면 변경되지 않은 것을 확인할 수 있습니다.
  
## Call by Reference
 - 함수의 인자로 &(Ampersand)를 받게 될 경우, 인자의 값을 복사하는 것이 아닌 인자의 주소값(포인터)를 사용하기 떄문에
   값이 아닌 주소값을 가리키는 것이므로 함수 내부에서 인자의 값을 변경하게 될 경우, 함수 종료 이후에 값을 확인해보면 변경된 값을 확인 할 수 있습니다.
  
## Call by Address
 - 함수의 인자로 *(Asterisk)를 받게 될 경우, 함수 호출하는 곳에서는 주소를 명시적으로 전달해야 합니다.
 - 함수는 인자로 주소를 받는데, 이 경우 함수 호출하는 곳에서는 값을 그대로 넘기지만 받는 측에서는 포인터로 받습니다.
 - 함수에 인자를 전달 할 때 변수의 주소를 명시적으로 알려주면 포인터의 크기로 인자가 넘어가지만,
   함수를 호출할 때 변수를 넣고 넘어오는 값을 포인터로 받으면 자료형만큼의 바이트만 사용합니다.


  
## 선언 (Declaration)
 - 코드에 사용되는 '어떤 대상'의 이름과 타입을 컴파일러에게 알려주는 것. 구체적인 세부사항은 선언에 들어있지 않습니다.
   
## 시그니처 (Signature)
 - 모든 함수 선언문에 매개변수 리스트와 반환 타입이 나와있는 것을 말합니다.
 - 함수의 경우 시그니처가 그 함수의 타입입니다.
 - 공식적인 C++ 정의에서는 함수의 반환 타입을 시그니처에서 제외하고 있습니다.
  
## 정의 (Definition)
 - 선언에서 빠진 구체적인 세부사항을 컴파일러에게 제공하는 것입니다.
 - 객체의 경우에 있어서 정의는 컴파일러가 그 객체에 대한 메모리를 마련해 놓는 부분이 됩니다.
 - 클래스 혹은 클래스 템플릿의 경우에는 그 클래스 혹은 템플릿의 멤버를 넣어 준 결과가 정의입니다.
  
## 초기화 (Initialization)
 - 어떤 객체에 최초의 값을 부여하는 과정입니다.
 - 사용자 정의 타입으로 생성한 객체의 경우, 초기화는 생성자에 의해 이루어집니다.
  
## 기본 생성자(Deafult Constructor)
 - 어떤 인자도 주어지지 않은 채로 호출될 수 있는 생성자입니다. 원래부터 매개변수가 없거나 모든 매개변수가 기본 값을 갖고 있으면 기본 생성자가 될 수 있습니다.
  
## 복사 생성자 (Copy Constructor)
 - 어떤 객체의 초기화를 위해 그와 같은 타입의 객체로부터 초기화할 때 호출되는 함수입니다. (ex. Pass by Value)
  
## 복사 대입 연산자 (Copy Assignment Operator)
 - 정의되지 않은 동작.
 - 실행 시간에 어떤 현상이 터질지 확실히 예측할 수 없다는 뜻입니다.
 - 널 포인터를 역참조하면 미정의 동작이 발생합니다.
 - 유효하지 않은 배열 원소 지정번호(Index)로 참조하려 하면 미정의 동작이 발생합니다.